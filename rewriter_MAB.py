from utils import *
import pexpect

class MABRewriter:
    def __init__(self, bandit, samples_manager):
        self.data_path = 'data/'
        self.conf_path = 'conf/'
        self.randomize_path = Utils.get_randomized_folder() 
        #self.benign_section_content_path = self.data_path + 'benign_section_content/'
        self.recopy = True

        self.bandit = bandit
        self.samples_manager = samples_manager
        self.exit = False
        
    def run_once(self):
        logger_rew.info('====================== %s =====================' %Utils.get_classifier_name())
        for sample in self.samples_manager.list_sample:
            md5 = sample.get_md5(sample.path)
            print(sample.path, md5)
            for arm in self.bandit.list_arm:
                if arm.action == 'CR':
                    continue
                output_path = arm.pull(sample)
                print(output_path)
                if os.path.exists(output_path):
                    md5_arm = sample.get_md5(output_path)
                    if md5 == md5_arm:
                        print('same arm output. rm %s' %output_path)
                        os.system('rm %s' %output_path)
                with open(sample.path, 'rb') as fp:
                    bytez = fp.read()
                    bytez_new = modify_without_breaking(bytez, [ACTION_MAP[arm.action]])
                    output_path_gym = output_path + '_gym'
                    with open(output_path_gym, 'wb') as fp_out:
                        fp_out.write(bytez_new)
                        if os.path.exists(output_path_gym):
                            md5_arm = sample.get_md5(output_path_gym)
                            if md5 == md5_arm:
                                print('same gym output. rm %s' %output_path_gym)
                                os.system('rm %s' %output_path_gym)
        print('rename \'s/\./\_/\' %s/*' %(os.path.dirname(output_path)))
        os.system('rename \'s/\./\_/\' %s/*' %(os.path.dirname(output_path)))

    def run(self):
        self.samples_manager.get_initial_pending_list()
        trial_amount = self.samples_manager.get_count_with_status('pending') * Utils.get_average_pull()
        #logger_rew.info('trial_amount: %d' %trial_amount)
        logger_rew.info('TS: %d update parent: %d' %(Utils.is_thompson_sampling(), Utils.get_update_parent()))

        total_pull_count = 0
        logger_rew.info('===========================================')
        process_count = 0
        count_skip = 0
        count_solve = 0
        count_need = 0
        while(total_pull_count < trial_amount):
            sample = self.samples_manager.get_next_pending_sample()
            if sample:
                arm = self.bandit.get_next_arm(sample, sample.get_applied_actions())
                output_path = arm.pull(sample)
                sample.set_current_exe_path(output_path)
                sample.append_arm(arm)
                total_pull_count += 1
                if Utils.get_classifier_evaluate_type() == 'scan_folder':
                    sample.copy_to_scan_folder(rewriter_scan_folder)
                process_count += 1
                if process_count % 200 == 0:            # update every x pulls (defalut: 200)
                    logger_rew.info('update rewriter working list')
                    self.samples_manager.update_working_list()
            else:
                logger_rew.info('All pending samples are processing by arms, or more than %d samples are handing at the same time' %self.samples_manager.sample_concurrent_limit)
                time.sleep(1)
                self.samples_manager.update_working_list()

            count_skip = self.samples_manager.get_count_with_status('skip')
            count_evasive = self.samples_manager.get_count_with_status('evasive')
            count_minimal = self.samples_manager.get_count_with_status('minimal')
            count_functional = self.samples_manager.get_count_with_status('functional')
            count_need = len(self.samples_manager.list_sample) - count_skip
            logger_rew.info('-----------------------------------------------')
            logger_rew.info('### [%d/%d (%.2f%%)] skip: %d evasive: %d/%d (%.2f%%) minimal: %d functioanl: %d' \
                    %(total_pull_count, trial_amount, total_pull_count/trial_amount * 100, count_skip, \
                    count_evasive + count_minimal + count_functional, count_need, \
                    ((count_evasive + count_minimal + count_functional)/count_need*100), \
                    count_minimal + count_functional, count_functional))
            logger_rew.info('-----------------------------------------------')

            if count_functional + count_skip == len(self.samples_manager.list_sample):
                break

        # wait for remaining working samples
        logger_rew.info('wait for remaining working samples')
        while True:
            count_working = self.samples_manager.get_count_with_status('working')
            count_evasive = self.samples_manager.get_count_with_status('evasive')
            count_minimal = self.samples_manager.get_count_with_status('minimal')
            #print(count_working, count_evasive, count_minimal)
            if Utils.is_cuckoo_enable():
                if count_working + count_evasive + count_minimal == 0:
                    break
            else:
                if count_working + count_evasive == 0:
                    break
            #logger_rew.info('count_working: %d' %count_working)
            logger_rew.info('count_working: %d, count_evasive: %d, count_minimal: %d' %(count_working, count_evasive, count_minimal))
            self.samples_manager.update_working_list()
            time.sleep(10)

        logger_rew.info('delete tmp files')
        list_pending = self.samples_manager.get_samples_with_status('pending')
        for sample in list_pending:
            sample.delete_tmp_files(rewriter_output_folder)

        logger_rew.info('%%%%%%%%%%%%%%%%%%%%%%%% Rewriter Finish %%%%%%%%%%%%%%%%%%%%%%%%')
        self.exit = True
    
    #def create_folders(self):
    #    if Utils.get_classifier_evaluate_type() == 'scan_folder':
    #        cmd = 'sudo umount %s' %Utils.get_share_folder()
    #        print(cmd)
    #        os.system(cmd)
    #        #p = pexpect.spawn( cmd )
    #        #p.expect( ": " )
    #        #p.sendline(Utils.get_host_password())

    #        cmd = 'sudo mount -t cifs -o username=%s,domain=MYDOMAIN,uid=1000 //%s/share/ %s' %(Utils.get_vm_username(), Utils.get_vm_ip(), Utils.get_share_folder())
    #        print(cmd)
    #        os.system(cmd)
    #        #p = pexpect.spawn( cmd )
    #        #p.expect( ": " )
    #        #p.sendline(Utils.get_host_password())
    #        #p.expect( ": " )
    #        #p.sendline(Utils.get_vm_password())
    #        #print(Utils.get_vm_password())
    #        #output = p.read()

    #        time.sleep(3)   # manually check share folder is mounted or not

    #        os.system('rm -f %s/succ_action_count_update.sign' %self.conf_path)
    #        os.system('rm -f %s/rewriter_finish.sign' %self.conf_path)

        #os.system('mkdir -p log/')

        os.system('mkdir -p %s' %copy_tmp_folder)
        os.system('rm -fr %s/*' %copy_tmp_folder)

        os.system('mkdir -p %s' %rewriter_output_folder)
        os.system('rm -fr %s/*' %rewriter_output_folder)

        os.system('mkdir -p %s' %minimizer_output_folder)
        os.system('rm -fr %s/*' %minimizer_output_folder)

        os.system('mkdir -p %s' %rewriter_scan_folder)
        os.system('rm -fr %s/*' %rewriter_scan_folder)

        os.system('mkdir -p %s' %minimizer_scan_folder)
        os.system('rm -fr %s/*' %minimizer_scan_folder)

        os.system('mkdir -p %s' %evasive_folder)
        os.system('rm -fr %s/*' %evasive_folder)

        os.system('mkdir -p %s' %minimal_folder)
        os.system('rm -fr %s/*' %minimal_folder)

        os.system('mkdir -p %s' %functional_folder)
        os.system('rm -fr %s/*' %functional_folder)
    
        os.system('mkdir -p %s' %json_folder)
        os.system('rm -fr %s/*' %json_folder)
