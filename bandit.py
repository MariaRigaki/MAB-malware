from utils import *
import random
import pefile
import mmap
import copy
import hashlib
from scipy.stats import beta
import pexpect
import string
from manipulate2 import *

rewriter_vm_folder = Utils.get_share_folder() + 'rewriter/'
seq_minimizer_vm_folder = Utils.get_share_folder() + 'seq_minimizer/'
mic_minimizer_vm_folder = Utils.get_share_folder() + 'mic_minimizer/'
copy_tmp_folder = 'output/copy_tmp/'

rewriter_output_folder = 'output/rewriter_output/'
seq_minimizer_output_folder = 'output/seq_minimizer_output/'
mic_minimizer_output_folder = 'output/mic_minimizer_output/'

rewriter_evasive_folder = 'output/rewriter_evasive/'
seq_minimizer_evasive_folder = 'output/seq_minimizer_evasive/'
mic_minimizer_evasive_folder = 'output/mic_minimizer_evasive/'

random.seed(10)

os.system('mkdir -p log/')
logger_rew = Utils.setup_logger('rewriter', 'log/rewriter.log')
logger_seq = Utils.setup_logger('seq_minimizer', 'log/seq_minimizer.log')
logger_mic = Utils.setup_logger('mic_minimizer', 'log/mic_minimizer.log')

class Arm:
    def __init__(self, idx):
        #self.sample = ''
        self.idx = idx
        self.pull_count = 0
        self.action = None
        self.content = None
        self.name = None
        self.list_reward = []
        self.n_play = 0

    def update_name(self):
        self.name = self.action

    def pull(self, sample):
        logger_rew.info('pull Arm %s (%d)' %(self.name, self.idx))

        self.pull_count += 1
        return self.transfer(sample.current_exe_path, rewriter_output_folder)

    def transfer(self, input_path, output_folder):
        raise Exception ('Not Implemented')

    def estimated_probas(self):
        raise NotImplementedError

    def get_output_path(self, folder, input_path):
        return folder + os.path.basename(input_path) + '.' + self.action

    def get_overlay_size(self, sample_path):
        file_size = os.path.getsize(sample_path)
        pe = self.try_parse_pe(sample_path)
        if pe == None:
            logger_rew.info('action fail, no change')
            return 0
        overlay_offset = pe.get_overlay_data_start_offset()
        overlay_size = 0
        if overlay_offset != None:
            overlay_size = file_size - overlay_offset
        return overlay_size

    def try_parse_pe(self, sample_path):
        try:
            pe = pefile.PE(sample_path)
            return pe
        except Exception as e:
            logger_rew.info('pefile parse fail')
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            #logger_rew.info('==============================================')
            logger_rew.info('%s %s:%s cannot parse pe' %(exc_type, fname, exc_tb.tb_lineno))
            #logger_rew.info(e)
            #logger_rew.info('==============================================')

    def get_available_size_safe(self, pe, section_idx):
        target_section = pe.sections[section_idx]
    
        if section_idx < len(pe.sections) - 1:
            available_size = (pe.sections[section_idx+1].PointerToRawData - target_section.PointerToRawData) - target_section.Misc_VirtualSize
        else:           # the last section
            overlay_offset = pe.get_overlay_data_start_offset()
            if overlay_offset != None:      # pe has overlay data, the last section
                available_size = (overlay_offset - target_section.PointerToRawData) - target_section.Misc_VirtualSize
            else:       # no overlay data, the last section
                available_size = self.get_available_size(pe, section_idx)
    
        if available_size > 0x1000 or available_size < 0:
            available_size = 0
        return available_size

    def get_available_size(self, pe, section_idx):
        target_section = pe.sections[section_idx]
        available_size = target_section.SizeOfRawData - target_section.Misc_VirtualSize
        if available_size < 0:
            available_size = 0
        return available_size

    def print_section_names(self, pe):
        logger_rew.info(self.get_section_name_list(pe))

    def get_section_name_list(self, pe):
        return [str(section.Name.split(b'\0',1)[0]).split('\'')[1] for section in pe.sections]

    def zero_out_file_content(self, file_path, offset, segment_size):
        content = ('\x00'*(segment_size)).encode()
    
        fp_in = open(file_path, 'rb')
        file_content = fp_in.read()
        #logger_rew.info(len(file_content))
        fp_in.close()
    
        fp_out = open(file_path, 'wb')
        fp_out.write(file_content[:offset])
        fp_out.write(content)
        fp_out.write(file_content[offset + len(content):])
        fp_out.close()
    
    def align(self, val_to_align, alignment):
        return (int((val_to_align + alignment - 1) / alignment)) * alignment

class ArmOA(Arm):
    def __init__(self, idx, content_manager=None, content=None):
        super().__init__(idx)
        self.content_manager = content_manager
        self.content = content
        if content and len(content) == 1:
            self.action = 'OA1'
        else:
            self.action = 'OA'
        self.update_name()

    def update_name(self):
        if self.content == None:
            self.name = self.action + '+Rand'
        elif len(self.content) == 1:
            self.name = self.action + '+1'
        else:
            self.name = self.action + '+' + hashlib.md5(self.content).hexdigest()[:8]

    def set_content(self, content):
        self.content = content
        if len(content) == 1:
            self.action = 'OA1'
        self.update_name()

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        Utils.copy_file(input_path, output_path)
        if self.content == None:
            logger_rew.info('generating new random content')
            _, _, self.content = self.content_manager.get_an_unused_content()
        logger_rew.info('using arm idx: %d, len content: %d' %(self.idx, len(self.content)))
        with open(output_path, 'ab') as f:
            f.write(self.content)
        
        # verify action changes
        old_overlay_size = self.get_overlay_size(input_path)
        new_overlay_size = self.get_overlay_size(output_path)

        logger_rew.info('old overlay size: %d, new overlay size: %d' %(old_overlay_size, new_overlay_size))
        return output_path

class ArmRD(Arm):
    def __init__(self, idx):
        super().__init__(idx)
        self.action = 'RD'
        self.name = self.action

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        pe = pefile.PE(input_path)
        segment_size = 0
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_DEBUG':
                logger_rew.info('%s\t%s\t%s' %(d.name, hex(d.VirtualAddress), hex(d.Size)))
                if d.Size > 0:
                    debug_directories = pe.parse_debug_directory(d.VirtualAddress, d.Size)
                    if debug_directories:
                        for debug_directory in debug_directories:
                            debug_type = debug_directory.struct.Type
                            if debug_type == 2:
                                file_offset = debug_directory.struct.PointerToRawData
                                segment_size = debug_directory.struct.SizeOfData
                    d.VirtualAddress = 0
                    d.Size = 0

        pe.write(output_path)

        if segment_size > 0:
            # set_bytes_at_offset doesn't take effect, zero out directly.
            self.zero_out_file_content(output_path, file_offset, segment_size)

        # verify action changes
        pe = self.try_parse_pe(output_path)
        if pe:
            for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
                if d.name == 'IMAGE_DIRECTORY_ENTRY_DEBUG':
                    logger_rew.info('%s\t%s\t%s' %(d.name, hex(d.VirtualAddress), hex(d.Size)))
        else:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)

        return output_path

class ArmRC(Arm):
    def __init__(self, idx):
        super().__init__(idx)
        self.action = 'RC'
        self.name = self.action

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        pe = pefile.PE(input_path)
        for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                logger_rew.info('%s\t%s\t%s' %(d.name, hex(d.VirtualAddress), hex(d.Size)))
                if d.VirtualAddress > 0:
                    size_in_sig = pe.get_word_from_offset(d.VirtualAddress)
                    if size_in_sig == d.Size:
                        logger_rew.info('find sig')
                        pe.set_bytes_at_offset(d.VirtualAddress, ('\x00'*(d.Size)).encode())
                        d.VirtualAddress = 0
                        d.Size = 0

        pe.write(output_path)

        # verify action change
        pe = self.try_parse_pe(output_path)
        if pe:
            for d in pe.OPTIONAL_HEADER.DATA_DIRECTORY:
                if d.name == 'IMAGE_DIRECTORY_ENTRY_SECURITY':
                    logger_rew.info('%s\t%s\t%s' %(d.name, hex(d.VirtualAddress), hex(d.Size)))
        else:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)
        
        return output_path

class ArmCR(Arm):
    def __init__(self, idx):
        super().__init__(idx)
        self.action = 'CR'
        self.name = self.action

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        cr_path = Utils.get_randomized_folder() + Utils.get_ori_name(output_path) + '.CR'
        if os.path.exists(cr_path) == True:
            Utils.copy_file(cr_path, output_path)
            logger_rew.info('have CR file')
        else:
            logger_rew.info('do not have CR file')
            Utils.copy_file(input_path, output_path)

        # verify action change
        pe = self.try_parse_pe(output_path)
        if pe == None:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)
        
        return output_path

class ArmBC(Arm):
    def __init__(self, idx):
        super().__init__(idx)
        self.action = 'BC'
        self.name = self.action

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)
        pe = pefile.PE(input_path)
        checksum_before = pe.OPTIONAL_HEADER.CheckSum

        pe.OPTIONAL_HEADER.CheckSum = 0
        pe.write(output_path)

        # verify action changes
        pe = self.try_parse_pe(output_path)
        if pe:
            checksum_after = pe.OPTIONAL_HEADER.CheckSum
            logger_rew.info('CheckSum: before %s, after %s' %(hex(checksum_before), hex(checksum_after)))
        else:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)

        return output_path

class ArmSP(Arm):
    def __init__(self, idx, content_manager=None, section_idx=None, content=None):
        super().__init__(idx)
        self.content_manager = content_manager
        if section_idx != None and len(content) == 1:
            self.action = 'CP1'     # special case, only CP1 init with section_idx, SP1 only set_content
        else:
            self.action = 'SP'
        self.section_idx = section_idx
        self.content = content
        self.update_name()

    def update_name(self):
        if self.content == None:
            self.name = self.action + '+Rand'
        elif len(self.content) == 1:
            self.name = self.action + '+1'
        else:
            self.name = self.action + '+' + hashlib.md5(self.content).hexdigest()[:8]

    def set_content(self, content):
        self.content = content
        if len(content) == 1:
            self.action = 'SP1'
        self.update_name()

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)
        pe = pefile.PE(input_path)

        # find out all available_sections
        dict_idx_to_available_size = {}
        for idx, section in enumerate(pe.sections):
            available_size = self.get_available_size_safe(pe, idx)
            if available_size > 0:
                dict_idx_to_available_size[idx] = available_size
                
        if len(dict_idx_to_available_size) == 0:
            logger_rew.info('no section has free space, return the original sample')
            Utils.copy_file(input_path, output_path)
            return output_path

        append_section_idx = self.section_idx
        # arm first use, or cannot be directly applied
        if append_section_idx == None or append_section_idx not in dict_idx_to_available_size.keys():
            append_section_idx = random.choice(list(dict_idx_to_available_size.keys()))

        available_size = dict_idx_to_available_size[append_section_idx]

        # arm first use, save for later use 
        if self.section_idx == None:
            self.section_idx = append_section_idx
        if self.content == None:
            _, _, self.content = self.content_manager.get_an_unused_content()

        append_content = self.content
        if len(append_content) != 1:            # if it's SP1, do not need to extend content
            while available_size > len(append_content):   # extend content
                append_content += self.content                    
            append_content = bytes(append_content[:available_size])

        target_section = pe.sections[append_section_idx]
        pe.set_bytes_at_offset(target_section.PointerToRawData + target_section.Misc_VirtualSize, append_content)
        logger_rew.info('section_idx: %d, content lenth: %d' %(append_section_idx, len(append_content)))
        pe.write(output_path)

        # verify action changes
        pe = self.try_parse_pe(output_path)
        if pe == None:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)

        return output_path

class ArmSR(Arm):
    def __init__(self, idx, content_manager=None):
        super().__init__(idx)
        self.content_manager = content_manager
        self.action = 'SR'
        self.section_idx = None
        self.new_name = None
        self.old_name = None
        self.update_name()

    def update_name(self):
        if self.new_name == None:
            self.name = self.action + '+Rand'
        else:
            self.name = self.action + '+' + hashlib.md5((str(self.section_idx) + self.new_name).encode()).hexdigest()[:8]

    def mutate_old_name_one_byte(self):
        self.new_name = self.old_name
        new_name_list = list(self.old_name)
        while(self.new_name == self.old_name):
            name_idx = random.randint(0, len(list(self.old_name))-1)
            new_name_list[name_idx] = random.choice(string.ascii_lowercase)
            self.new_name = "".join(new_name_list)
        self.action = 'SR1'

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        pe = pefile.PE(input_path)
        list_section_name = self.get_section_name_list(pe)
        self.print_section_names(pe)

        if self.new_name == None and self.old_name == None and self.section_idx == None:
            # arm first use, create content
            section_idx = random.choice(range(len(list_section_name)))
            old_name = list_section_name[section_idx]
            new_name = old_name
            while new_name == old_name:
                new_name, _, _ = self.content_manager.get_an_unused_content()
                logger_rew.info(new_name)

            # save for reuse later is succ
            self.new_name = new_name
            self.section_idx = section_idx
            self.old_name = old_name

        else:
            # reuse succ arm
            new_name = self.new_name
            if self.old_name in list_section_name:
                section_idx = list_section_name.index(self.old_name)
            elif self.section_idx >= len(list_section_name):
                section_idx = random.choice(range(len(list_section_name)))
            else:
                section_idx = self.section_idx

        pe.sections[section_idx].Name = new_name.encode()
        pe.write(output_path)

        # verify action changes
        pe = self.try_parse_pe(output_path)
        if pe:
            self.print_section_names(pe)
        else:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)

        return output_path

class ArmSA(Arm):
    def __init__(self, idx, content_manager=None, content=None):
        super().__init__(idx)
        self.content_manager = content_manager
        self.content = content
        if content and len(content) == 1:
            self.action = 'SA1'
        else:
            self.action = 'SA'

        self.section_name = None

        self.name = None
        self.update_name()
    
    def set_content(self, content):
        self.content = content
        if len(content) == 1:
            self.action = 'SA1'
        self.update_name()

    def update_name(self):
        if self.content == None:
            self.name = self.action + '+Rand'
        elif len(self.content) == 1:
            self.name = self.action + '+1'
        else:
            self.name = self.action + '+' + hashlib.md5(self.content).hexdigest()[:8]

    def transfer(self, input_path, output_folder):
        logger_rew.info('=== %s ===' %self.action)
        output_path = self.get_output_path(output_folder, input_path)

        pe = pefile.PE(input_path)
        self.print_section_names(pe)
    
        if self.content == None:
            # arm first use
            self.section_name, _, self.content = self.content_manager.get_an_unused_content()

        number_of_section = pe.FILE_HEADER.NumberOfSections
        last_section = number_of_section - 1
        file_alignment = pe.OPTIONAL_HEADER.FileAlignment
        section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
        if last_section >= len(pe.sections):
            Utils.copy_file(input_path, output_path)
            return output_path
        new_section_header_offset = (pe.sections[number_of_section - 1].get_file_offset() + 40)
        next_header_space_content_sum = pe.get_qword_from_offset(new_section_header_offset) + \
                pe.get_qword_from_offset(new_section_header_offset + 8) + \
                pe.get_qword_from_offset(new_section_header_offset + 16) + \
                pe.get_qword_from_offset(new_section_header_offset + 24) + \
                pe.get_qword_from_offset(new_section_header_offset + 32)
        first_section_offset = pe.sections[0].PointerToRawData
        next_header_space_size = first_section_offset - new_section_header_offset
        if next_header_space_size < 40:
            logger_rew.info('no free space to add a new header before the fist section')
            Utils.copy_file(input_path, output_path)
            return output_path
        if next_header_space_content_sum != 0:
            logger_rew.info('exist hidden header or data, such as VB header')
            Utils.copy_file(input_path, output_path)
            return output_path
    
        file_size = os.path.getsize(input_path)
    
        # todo: hanlde alignment
        alignment = True
        if alignment == False:
            raw_size = 1
        else:
            raw_size = self.align(len(self.content), file_alignment)
        virtual_size = self.align(len(self.content), section_alignment)
    
        raw_offset = file_size
        #raw_offset = self.align(file_size, file_alignment)
    
        #log('1. Resize the PE file')
        Utils.copy_file(input_path, output_path)
        pe = pefile.PE(output_path)
        original_size = os.path.getsize(output_path)
        fd = open(output_path, 'a+b')
        map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
        map.resize(original_size + raw_size)
        map.close()
        fd.close()
    
        pe = pefile.PE(output_path)
        virtual_offset = self.align((pe.sections[last_section].VirtualAddress +
                            pe.sections[last_section].Misc_VirtualSize),
                            section_alignment)
    
        characteristics = 0xE0000020
        self.section_name = self.section_name + ('\x00' * (8-len(self.section_name)))
    
        #log('2. Add the New Section Header')
        hex(pe.get_qword_from_offset(new_section_header_offset))
        pe.set_bytes_at_offset(new_section_header_offset, self.section_name.encode())
        pe.set_dword_at_offset(new_section_header_offset + 8, virtual_size)
        pe.set_dword_at_offset(new_section_header_offset + 12, virtual_offset)
        pe.set_dword_at_offset(new_section_header_offset + 16, raw_size)
        pe.set_dword_at_offset(new_section_header_offset + 20, raw_offset)
        pe.set_bytes_at_offset(new_section_header_offset + 24, (12 * '\x00').encode())
        pe.set_dword_at_offset(new_section_header_offset + 36, characteristics)
    
        #log('3. Modify the Main Headers')
        pe.FILE_HEADER.NumberOfSections += 1
        pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset
        pe.write(output_path)
    
        #log('4. Add content for the New Section')
        pe.set_bytes_at_offset(raw_offset, self.content)
        pe.write(output_path)
        
        # verify action changes
        pe = self.try_parse_pe(output_path)
        if pe:
            self.print_section_names(pe)
            logger_rew.info('new section len: %d' %len(self.content))
        else:
            logger_rew.info('pefile cannot parse, restore original file')
            Utils.copy_file(input_path, output_path)
        
        return output_path

class Bandit:
    def __init__(self):
        #self.arm_limit = get_max_working_arm_count()
        self.content_manager = ContentManager('data/benign_section_content/')

        #self.list_working_arm = []
        #self.list_succ_arm = []
        self.samples_manager = None
        #self.list_benign_section_name = self.get_benign_section_name_list()

        self.list_arm = []
        self.list_arm.append(ArmOA(0, content_manager=self.content_manager))
        self.list_arm.append(ArmSA(1, content_manager=self.content_manager))
        self.list_arm.append(ArmSP(2, content_manager=self.content_manager))
        self.list_arm.append(ArmSR(3, content_manager=self.content_manager))
        self.list_arm.append(ArmRD(4))
        self.list_arm.append(ArmRC(5))
        self.list_arm.append(ArmBC(6))
        self.list_arm.append(ArmCR(7))
        self.idx_to_ori_idx = {}

        # Bayesian UCB
        #self.counts = [0] * len(self.list_arm)
        self.c = 3
        self._as = [1] * len(self.list_arm)
        self._bs = [1] * len(self.list_arm)
        #logger_rew.info(self.list_arm)

        #self.list_selected_arm_idx = []
    
    def get_next_arm(self, path, list_action):
        ## Bayesian UCB
        #list_value = [self._as[x] / float(self._as[x] + self._bs[x]) + beta.std(
        #        self._as[x], self._bs[x]) * self.c for x in range(len(self.list_arm))]
        #
        #logger_rew.info(list_value)
        #max_value = max(list_value)
        #list_max_value_idx = []
        #for idx, i in enumerate(list_value):
        #    if i == max_value:
        #        list_max_value_idx.append(idx)
        #idx = random.choice(list_max_value_idx)
        
        cr_path = Utils.get_randomized_folder() + Utils.get_ori_name(path) + '.CR'
        if len(list_action) == 0 and os.path.exists(cr_path):
            idx = 7
        else:
            while True:
                # Tompson Sampling
                samples = [np.random.beta(self._as[x], self._bs[x]) for x in range(len(self.list_arm))]
                idx = max(range(len(self.list_arm)), key=lambda x: samples[x])
                #self.list_arm.append(ArmRD(4))
                #self.list_arm.append(ArmRC(5))
                #self.list_arm.append(ArmBC(6))
                #self.list_arm.append(ArmCR(7))
                if idx not in [4,5,6,7]:
                    break
                else:
                    if (idx == 4 and 'RD' not in list_action) or (idx == 5 and 'RC' not in list_action) or (idx == 6 and 'BC' not in list_action):
                        break
                    #else:
                    #    logger_rew.info('does not need %d again for a sample with %s' %(idx, list_action))

        arm = copy.deepcopy(self.list_arm[idx])
        return arm

    def update_arm_with_reward(self, idx, reward):#, minimizer=False):
        if Utils.get_thompson_sampling() == False:
            return

        # Bayesian UCB
        # Update Gaussian posterior
        #if minimizer == False:
        self._as[idx] += reward
        self._bs[idx] += (1 - reward)
        #else:
        #    logger_rew.info('minimizer update reward!')
        #    self._as[idx] += 1
        #    #self._bs[idx] += -1
        
        if Utils.get_update_parent():
            #if child succ, give ori reward too!
            if reward == 1:
                if idx in self.idx_to_ori_idx:
                    ori_idx = self.idx_to_ori_idx[idx]
                    self._as[ori_idx] += reward
                    #self._bs[ori_idx] += (1 - reward)

    def add_new_arm(self, new_arm):
        if Utils.get_thompson_sampling() == False:
            return
        ori_idx = new_arm.idx
        new_arm.idx = len(self.list_arm)

        self.idx_to_ori_idx[new_arm.idx] = ori_idx
        
        # find existing arm
        new_arm.update_name()
        for idx, arm in enumerate(self.list_arm):
            if arm.name == new_arm.name:    # arm already exist, update existing arm
                logger_rew.info('no need to add a new arm, update existing arm')
                self._as[idx] += 1
                return

        # add a new arm, append _as _bs
        self.list_arm.append(new_arm)
        # Bayesian UCB
        #self._as.append(self._as[ori_idx])
        #self._bs.append(self._bs[ori_idx])
        self._as.append(1)
        self._bs.append(1)

class Sample:
    def __init__(self, path):
        self.path = path
        self.sname = Utils.short_name(self.path)
        self.set_current_exe_path(self.path)
        self.max_length = Utils.get_max_length()
        self.copy_time = None
        self.vm_status = None
        self.list_applied_arm = []

        self.current_applied_arm_subset = []
        self.current_seq_action_idx = 0
        self.list_removed_idx = []
        self.list_seq_minimized_arm = []
        self.latest_evasive_minimized_exe_path = None

        self.current_applied_arm_subset_mic = []
        self.current_seq_action_idx_mic = 0
        self.current_mic_action_idx = 0
        self.action_idx_to_kept_mic_arm = {}
        self.list_mic_minimized_arm = []
        self.latest_evasive_minimized_exe_path_mic = None

    def set_current_exe_path(self, path):
        self.current_exe_path = path
        self.current_exe_md5 = self.get_md5(path)
        #logger_rew.info('set %s md5 %s' %(path, self.current_exe_md5))

    def inc_action_idx(self):
        #if self.current_seq_action_idx_mic < len(self.list_applied_arm) - 1:
        self.current_seq_action_idx_mic += 1
        self.current_mic_action_idx = 0
    
    def inc_mic_action_idx(self):
        action = self.list_seq_minimized_arm[self.current_seq_action_idx_mic].action
        list_mic_action = []
        if action in ACTION_TO_MICROACTION:
            list_mic_action = ACTION_TO_MICROACTION[action]

        if self.current_mic_action_idx < len(list_mic_action) - 1:
            self.current_mic_action_idx += 1
        else:
            self.inc_action_idx()

    def get_md5(self, path):
        if os.path.exists(path) == False:
            logger_rew.info('error! file not exists: %s' %path)
            return None
        hash_md5 = hashlib.md5()
        try:
            with open(path, 'rb') as f:
                content = f.read()
                #for chunk in iter(lambda: f.read(4096), b''):
                #    logger_rew.info('3')
                hash_md5.update(content)
                #logger_rew.info(len(content))
                md5 = hash_md5.hexdigest()
            #logger_rew.info('md5: %s' %md5)
            return md5
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            #logger_rew.info('==============================================')
            #logger_rew.info('cannot read the file to get the md5')
            logger_rew.info('%s %s:%s cannot get md5' %(exc_type, fname, exc_tb.tb_lineno))
            #logger_rew.info(e)
            #logger_rew.info('==============================================')
            return None

    def delete_applied_arm(self):
        # clean attributes
        #self.copy_time = None       # need?
        #self.vm_status = None       # need?

        # clean arms
        for arm in self.list_applied_arm:
            del arm
        self.list_applied_arm = []

    def delete_tmp_files(self, folder):
        logger_rew.info('delete generated tmp files in %s' %folder)
        # todo: handle file_name with '.'
        os.system('rm -f %s/%s.*' %(folder, os.path.basename(self.path)))
        self.set_current_exe_path(self.path)

    def append_arm(self, arm):
        self.list_applied_arm.append(arm)

    def copy_to_vm(self, vm_folder):
        #md5 = self.get_md5(self.current_exe_path)
        self.vm_status = 'waiting'
        self.copy_time = time.time()
        Utils.copy_file(self.current_exe_path, vm_folder + os.path.basename(self.current_exe_path + '.exe'))

    def check_rename(self, path):
        tmp_path = os.path.dirname(path) + '/__tmp__' + os.path.basename(path)
        try:
            if os.path.exists(path):
                os.system('mv %s %s' %(path, tmp_path))
                if os.path.exists(tmp_path):
                    os.system('mv %s %s' %(tmp_path, path))
                    if os.path.exists(path):
                        return True
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            #logger_rew.info('==============================================')
            logger_rew.info('%s %s:%s cannot rename' %(exc_type, fname, exc_tb.tb_lineno))
            #logger_rew.info(e)
            #logger_rew.info('==============================================')
        return False 

    def check_md5(self, vm_filepath):
        vm_file_md5 = self.get_md5(vm_filepath)
        #logger_rew.info('%s: %s %s' %(self.sname, vm_file_md5, self.current_exe_md5))
        if vm_file_md5 and self.current_exe_md5:
            if vm_file_md5 == self.current_exe_md5:
                return True
            else:
                logger_rew.info('%s: md5 changed. delete file.' %self.sname)
                os.system('rm -f %s' %vm_filepath)
                return False
        return None

    def check_copy_time(self):
        wait_time = Utils.get_wait_time()
        existing_time = time.time() - self.copy_time
        #logger_rew.info('exising_time: %d/%d' %(existing_time, wait_time))
        if existing_time > wait_time:
            return True
        else:
            return False

    def delete_vm_copy(self, vm_folder):
        os.system('rm -f %s/%s*' %(vm_folder, os.path.basename(self.path)))

    def check_file_status(self, vm_folder):
        Utils.wait_on_stop_sign()
        if 'ember' in Utils.get_av_name() or 'clamav' in Utils.get_av_name() or 'malconv' in Utils.get_av_name():
            status = 'deleted'
            for vm_filename in os.listdir(vm_folder):
                if Utils.get_ori_name(vm_filename) == os.path.basename(self.path):
                    if '.benign' in vm_filename:
                        status = 'evasive'
                    else:
                        status = 'waiting'
                    break
            self.status = status
            if status in ['evasive', 'deleted']:
                os.system('rm -f %s/*%s*' %(vm_folder, os.path.basename(self.path)))
            return status
        else:
            list_file = []
            try:
                list_file = [vm_folder + x for x in os.listdir(vm_folder)]
            except Exception as e:
                exc_type, exc_obj, exc_tb = sys.exc_info()
                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                logger_rew.info('%s %s:%s cannot listdir' %(exc_type, fname, exc_tb.tb_lineno))
                logger_rew.info(e)
            for vm_filepath in list_file:
                if Utils.get_ori_name(vm_filepath) == os.path.basename(self.path):
                    md5_status = self.check_md5(vm_filepath)
                    #logger_rew.info(md5_status)
                    if md5_status == None:      # cannot access file to get md5
                        if self.check_copy_time():
                            status = 'overtime'
                        else:
                            status = 'waiting'
                    elif md5_status == False:   # file md5 is changed
                        if self.check_rename(vm_filepath):
                            status = 'deleted'
                        else:
                            if self.check_copy_time():  # may not need
                                status = 'overtime'
                            else:
                                status = 'waiting'
                    else:                       # file md5 stay the same
                        if self.check_copy_time():
                            if self.check_rename(vm_filepath):
                                logger_rew.info('%s: md5 ok; time ok; rename ok' %self.sname)
                                status = 'evasive'
                            else:
                                logger_rew.info('%s: cannot rename' %self.sname)
                                status = 'overtime'
                        else:
                            status = 'waiting'  # time is not long enough
                    self.status = status
                    #logger_rew.info(self.status)
                    if status in ['evasive', 'deleted']:
                        os.system('rm -f %s/*%s*' %(vm_folder, os.path.basename(self.path)))
                    return status
            #logger_rew.info('%s: file not exist' %self.sname)
            status = 'deleted'
            os.system('rm -f %s/*%s*' %(vm_folder, os.path.basename(self.path)))
            self.status = status
            return status

    def get_current_arm_subset(self):
        #list_subset_idx = [idx for idx, x in enumerate(self.list_applied_arm) if idx not in self.list_removed_idx and idx != self.current_seq_action_idx]
        #logger_seq.info('subset_idx: %s' %list_subset_idx)
        self.current_applied_arm_subset = [x for idx, x in enumerate(self.list_applied_arm) if idx not in self.list_removed_idx and idx != self.current_seq_action_idx]

    def get_current_mic_arm_list(self):
        list_arm = copy.deepcopy(self.list_seq_minimized_arm)

        # replace kept arm
        logger_mic.info('%s: replace kept arm' %self.sname)
        for k, v in self.action_idx_to_kept_mic_arm.items():
            logger_mic.info('%s: %d' %(self.sname, k))
            list_arm[k] = v

        logger_mic.info('%s: list_arm: %s' %(self.sname, self.get_names_from_arm_list(list_arm)))
        logger_mic.info('%s: %d %d' %(self.sname, self.current_seq_action_idx_mic, self.current_mic_action_idx))

        if self.current_seq_action_idx_mic < len(self.list_seq_minimized_arm):
            action = self.list_seq_minimized_arm[self.current_seq_action_idx_mic].action
            #logger_mic.info('%s: %s' %(self.sname, action))

            list_mic_action = []
            if action in ACTION_TO_MICROACTION:
                list_mic_action = ACTION_TO_MICROACTION[action]

            #logger_mic.info('%s %s' %(self.sname, list_mic_action))
            
            if self.current_mic_action_idx < len(list_mic_action):
                micro_action = list_mic_action[self.current_mic_action_idx]
                #logger_mic.info('%s: %s' %(self.sname, micro_action))

                #self.list_arm.append(ArmOA(0, content_manager=self.content_manager))
                #self.list_arm.append(ArmSA(1, content_manager=self.content_manager))
                #self.list_arm.append(ArmSP(2, content_manager=self.content_manager))
                #self.list_arm.append(ArmSR(3, content_manager=self.content_manager))
                #self.list_arm.append(ArmRD(4))
                #self.list_arm.append(ArmRC(5))
                #self.list_arm.append(ArmBC(6))
                #self.list_arm.append(ArmCR(7))

                if micro_action == 'OA':        # only SA need to be minimized to OA
                    content = self.list_seq_minimized_arm[self.current_seq_action_idx_mic].content
                    micro_arm = ArmOA(0, content=content)
                elif micro_action == 'OA1':
                    micro_arm = ArmOA(0, content=bytes([1]))
                elif micro_action == 'SA1':     # only SA need to be minimized to SA1
                    micro_arm = copy.deepcopy(self.list_seq_minimized_arm[self.current_seq_action_idx_mic])
                    micro_arm.set_content(bytes([1]))
                elif micro_action == 'SP1':     # only SP need to be minimized to SP1
                    micro_arm = copy.deepcopy(self.list_seq_minimized_arm[self.current_seq_action_idx_mic])
                    micro_arm.set_content(bytes([1]))
                elif micro_action == 'SR1':     # only SR need to be minimized to SR1
                    micro_arm = copy.deepcopy(self.list_seq_minimized_arm[self.current_seq_action_idx_mic])
                    micro_arm.mutate_old_name_one_byte()
                elif micro_action == 'CP1':
                    pe = pefile.PE(self.path)
                    code_section_idx = None
                    for section_idx, section in enumerate(pe.sections):
                        logger_mic.info('%s: %d, %s' %(self.sname, section_idx, section.Name[:5].decode('utf-8')))
                        logger_mic.info(len(section.Name[:5].decode('utf-8')))
                        if section.Name[:5].decode('utf-8') == '.text':
                            code_section_idx = section_idx
                            logger_mic.info('%s: find .text in section_idx %d' %(self.sname, code_section_idx))
                            break
                    if code_section_idx != None:
                        micro_arm = ArmSP(2, section_idx=code_section_idx, content=bytes([1]))
                    else:
                        logger_mic.info('%s: cannot find code section' %self.sname)
                        micro_arm = None
                else:
                    logger_mic.error('%s: micro_action unexpected' %self.sname)
                    exit()
                list_arm[self.current_seq_action_idx_mic] = micro_arm
                logger_mic.info('%s: replaced one microaction: %s' %(self.sname, self.get_names_from_arm_list(list_arm)))
            #else:
            #    self.current_seq_action_idx_mic += 1
            #    self.current_mic_action_idx = 0
            self.current_applied_arm_subset_mic = list_arm
            #logger_mic.info('mic_action_idx_to_kept_arm: %s' %self.mic_action_idx_to_kept_arm)
        #    return True
        #else:
        #    return False

    def get_names_from_arm_list(self, list_arm):
        list_arm_name = []
        for x in list_arm:
            if x:
                list_arm_name.append(x.action)
            else:
                list_arm_name.append(None)
        return list_arm_name

    def replay_subset(self, subset, output_folder):
        if len(subset) == 0:
            #logger_seq.error('empty replay subset')
            #logger_mic.error('empty replay subset')
            exit()
        input_path = self.path
        for arm in subset:
            if arm:
                output_path = arm.transfer(input_path, output_folder)
                input_path = output_path
                self.set_current_exe_path(output_path)
        #logger_rew.info('output_path: %s' %output_path)

    #def replace_with_micro_actions(self):
    #    pass
    
    def get_applied_actions(self):
        return self.get_names_from_arm_list(self.list_applied_arm)

class SamplesManager:
    def __init__(self, sample_folder, bandit):
        self.sample_folder = sample_folder
        self.bandit = bandit
        self.bandit.samples_manager = self

        self.list_all = []
        self.list_unsolve = []
        self.list_rewriter_working = []
        self.list_seq_minimizer_working = []
        self.list_mic_minimizer_working = []
        self.sample_concurrent_limit = Utils.get_max_working_sample_count()

        self.list_evasive = []
        self.list_evasive_seq_minimized = []
        self.list_evasive_mic_minimized = []
        self.list_skip = []
        list_sample = os.listdir(sample_folder)
        list_sample.sort()
        for x in list_sample:
            sample = Sample(self.sample_folder + x)
            self.list_all.append(sample)

    #def get_next_unsolve_sample(self, action):
    #    if len(self.list_unsolve) > 0:
    #        for _ in range(10):  # try 3 times
    #            sample = random.choice(self.list_unsolve)
    #            # some actions should only be applied once
    #            if action == 'CR' and len(sample.get_applied_actions()) > 0:
    #                logger_rew.info('selected sample %s has applied other actions, CR should be the first action' %(sample.get_applied_actions()))
    #                continue
    #            elif action in ['BC', 'RC', 'RD'] and action in sample.get_applied_actions():
    #                logger_rew.info('selected sample %s does not need %s again' %(sample.get_applied_actions(), action))
    #                #print(action, sample.get_applied_actions())
    #                continue
    #            elif len(self.list_rewriter_working) >= self.sample_concurrent_limit:
    #                logger_rew.info('concurrent sample %d is more than %d, waiting...' %(len(self.list_rewriter_working), self.sample_concurrent_limit))
    #                return None
    #            else:
    #                self.list_unsolve.remove(sample)
    #                self.list_rewriter_working.append(sample)
    #                logger_rew.info('select unsolve sample: %s' %sample.sname)
    #                logger_rew.info('len(self.list_rewriter_working): %d' %len(self.list_rewriter_working))
    #                return sample

    def get_next_unsolve_sample(self):
        if len(self.list_unsolve) > 0:
            for _ in range(10):  # try 3 times
                sample = random.choice(self.list_unsolve)
                # some actions should only be applied once
                #if action == 'CR' and len(sample.get_applied_actions()) > 0:
                #    logger_rew.info('selected sample %s has applied other actions, CR should be the first action' %(sample.get_applied_actions()))
                #    continue
                #elif action in ['BC', 'RC', 'RD'] and action in sample.get_applied_actions():
                #    logger_rew.info('selected sample %s does not need %s again' %(sample.get_applied_actions(), action))
                #    #print(action, sample.get_applied_actions())
                #    continue
                if len(self.list_rewriter_working) >= self.sample_concurrent_limit:
                    logger_rew.info('concurrent sample %d is more than %d, waiting...' %(len(self.list_rewriter_working), self.sample_concurrent_limit))
                    return None
                else:
                    self.list_unsolve.remove(sample)
                    self.list_rewriter_working.append(sample)
                    logger_rew.info('select unsolve sample: %s' %sample.sname)
                    logger_rew.info('len(self.list_rewriter_working): %d' %len(self.list_rewriter_working))
                    return sample

    def get_ori_unsolve_list(self, vm_folder):
        logger_rew.info('check whether AV can detect unchanged samples...')
        for sample in self.list_all:
            sample.copy_to_vm(rewriter_vm_folder)
            #time.sleep(0.1)
        logger_rew.info('copy to vm finish')
        while(True):
            for sample in self.list_all:
                if sample not in self.list_unsolve and sample not in self.list_skip:
                    vm_status = sample.check_file_status(rewriter_vm_folder)
                    #logger_rew.info('%s: %s' %(sample.sname, vm_status))
                    if vm_status in ['deleted', 'overtime']:
                        self.list_unsolve.append(sample)
                    elif vm_status == 'evasive':
                        self.list_skip.append(sample)
            len_unsolve = len(self.list_unsolve)
            len_skip = len(self.list_skip)
            len_all = len(self.list_all)
            logger_rew.info('(%d/%d): detect %d, fail %d' %(len_unsolve + len_skip, len_all, len_unsolve, len_skip))
            time.sleep(1)
            if len(self.list_unsolve) + len(self.list_skip) == len(self.list_all):
                break
        logger_rew.info('check finish.')
        logger_rew.info('remove remaining files.')
        os.system('rm -f %s/*' %(vm_folder))
        return self.list_unsolve

    # remove redundant macro actions
    def seq_minimize_evasive_sample(self):
        #logger_seq.info('-------------------------------------------------------')
        #logger_seq.info('len list_evasive: %d' %len(self.list_evasive))
        #logger_seq.info('len list_evasive_seq_minimized: %d' %len(self.list_evasive_seq_minimized))
        for sample in self.list_evasive:
            if sample not in self.list_evasive_seq_minimized:
                #logger_seq.info('%s: %s %s cur_idx:%s' %(sample.sname, sample.vm_status, sample.get_applied_actions(), sample.current_seq_action_idx))
                if sample.vm_status == 'deleted':
                    if sample.current_seq_action_idx < len(sample.list_applied_arm) - 1:
                        sample.get_current_arm_subset()
                        sample.replay_subset(sample.current_applied_arm_subset, seq_minimizer_output_folder)
                        logger_seq.info('%s: %s removed:%s cur_idx:%s %s' %(sample.sname, sample.get_names_from_arm_list(sample.list_applied_arm), sample.list_removed_idx, sample.current_seq_action_idx, sample.get_names_from_arm_list(sample.current_applied_arm_subset)))
                        sample.copy_to_vm(seq_minimizer_vm_folder)
                        #logger_seq.info('apply subset to generate: %s' %os.path.basename(sample.current_exe_path))

    # seq seq seq
    def update_seq_minimizer_list(self):
        for sample in self.list_evasive:
            if sample not in self.list_evasive_seq_minimized:
                #logger_seq.info('%s: [%s]' %(sample.sname, sample.vm_status))
                if sample.vm_status in ['waiting', 'overtime']:
                    vm_status = sample.check_file_status(seq_minimizer_vm_folder)
                    #logger_seq.info('%s: [%s]' %(sample.sname, vm_status))
                    if vm_status == 'deleted':
                        logger_seq.info('%s: [%s]' %(sample.sname, vm_status))
                        sample.current_seq_action_idx += 1
                        sample.vm_status = 'deleted'
                    elif vm_status == 'evasive':
                        logger_seq.info('%s: [%s]' %(sample.sname, vm_status))
                        logger_seq.info('%s: ### seq minimize remove one action succ! %s' %(sample.sname, sample.current_exe_path))
                        sample.list_removed_idx.append(sample.current_seq_action_idx)
                        sample.current_seq_action_idx += 1
                        sample.latest_evasive_minimized_exe_path = sample.current_exe_path
                        sample.delete_vm_copy(seq_minimizer_vm_folder)
                        sample.vm_status = 'deleted'
                        sample.list_seq_minimized_arm = sample.current_applied_arm_subset
                if sample.current_seq_action_idx >= len(sample.list_applied_arm) - 1:
                    logger_seq.info('%s: ###### seq minimize finish!!! add to list_evasive_seq_minimized' %sample.sname)
                    self.list_evasive_seq_minimized.append(sample)

                    if len(sample.list_seq_minimized_arm) == 0:
                        sample.list_seq_minimized_arm = sample.list_applied_arm

                    #logger_seq.info('list_seq_minimized_arm: %s' %sample.get_names_from_arm_list(sample.list_seq_minimized_arm))

                    #for idx, arm in enumerate(sample.list_seq_minimized_arm):
                    #    if idx < len(sample.list_seq_minimized_arm) - 1:
                    #for arm in sample.list_seq_minimized_arm:
                    #    logger_seq.info('%s: update_arm_with_reward %d %s %d' %(sample.sname, arm.idx, arm.name, 1))
                    #    self.bandit.update_arm_with_reward(arm.idx, 1)#, minimizer=True)

                    #    if arm.idx < 4:    # only first arms use random content
                    #        logger_seq.info('add new arm')
                    #        self.bandit.add_new_arm(arm)

                    if sample.latest_evasive_minimized_exe_path:
                        logger_seq.info('%s: copy %s' %(sample.sname, sample.latest_evasive_minimized_exe_path))
                        Utils.copy_file(sample.latest_evasive_minimized_exe_path, seq_minimizer_evasive_folder)
                    else:       # only one action, not need minimization
                        path = rewriter_evasive_folder + os.path.basename(sample.path) + '*'
                        logger_seq.info('%s: no evasive in seq minimization, copy %s' %(sample.sname, path))
                        Utils.copy_file(path, seq_minimizer_evasive_folder)

    # Use micro actions to replace macro actions
    def mic_minimize_evasive_sample(self):
        for sample in self.list_evasive_seq_minimized:
            if sample not in self.list_evasive_mic_minimized:
                if sample.vm_status == 'deleted':
                    if sample.current_seq_action_idx_mic < len(sample.list_seq_minimized_arm):
                        sample.get_current_mic_arm_list()
                        sample.replay_subset(sample.current_applied_arm_subset_mic, mic_minimizer_output_folder)
                        logger_mic.info('%s: %s cur_idx:%s %s' %(sample.sname, sample.get_names_from_arm_list(sample.list_seq_minimized_arm), sample.current_seq_action_idx_mic, sample.get_names_from_arm_list(sample.current_applied_arm_subset_mic)))
                        sample.copy_to_vm(mic_minimizer_vm_folder)
                        #logger_mic.info('%s: apply subset to generate: %s' %(sample.sname, os.path.basename(sample.current_exe_path)))

    # mic mic mic
    def update_mic_minimizer_list(self, rewriter_exit):
        for sample in self.list_evasive_seq_minimized:
            if sample not in self.list_evasive_mic_minimized:
                if sample.vm_status in ['waiting', 'overtime']:
                    vm_status = sample.check_file_status(mic_minimizer_vm_folder)
                    if vm_status == 'deleted':
                        logger_mic.info('%s: [%s]' %(sample.sname, vm_status))
                        sample.vm_status = 'deleted'
                        sample.inc_mic_action_idx()
                        # todo: add arm directly (optional)
                    elif vm_status == 'evasive':
                        logger_mic.info('%s: [%s]' %(sample.sname, vm_status))
                        logger_mic.info('%s: ### mic minimize succ! %s' %(sample.sname, sample.current_exe_path))
                        sample.action_idx_to_kept_mic_arm[sample.current_seq_action_idx_mic] = sample.current_applied_arm_subset_mic[sample.current_seq_action_idx_mic]
                        #logger_mic.info([k, v.action] for k, v in sample.action_idx_to_kept_mic_arm.items())
                        sample.latest_evasive_minimized_exe_path_mic = sample.current_exe_path
                        sample.delete_vm_copy(mic_minimizer_vm_folder)
                        sample.vm_status = 'deleted'
                        sample.list_mic_minimized_arm = sample.current_applied_arm_subset_mic
                        sample.inc_action_idx()
                #logger_mic.info('%s: current_seq_action_idx_mic: %d len(sample.list_mic_minimized_arm): %d' %(sample.sname, sample.current_seq_action_idx_mic, len(sample.list_seq_minimized_arm)))
                if sample.current_seq_action_idx_mic >= len(sample.list_seq_minimized_arm):
                    logger_mic.info('%s: ###### mic minimize finish!!! add to list_evasive_mic_minimized' %sample.sname)
                    self.list_evasive_mic_minimized.append(sample)

                    logger_mic.info('list_mic_minimized_arm: %s' %sample.get_names_from_arm_list(sample.list_mic_minimized_arm))

                    if len(sample.list_mic_minimized_arm) == 0:
                        sample.list_mic_minimized_arm = sample.list_seq_minimized_arm

                    for arm in sample.list_mic_minimized_arm:
                        logger_mic.info('%s: update_arm_with_reward %d %s %d' %(sample.sname, arm.idx, arm.name, 1))
                        if arm.idx < 0:
                            logger_mic.info('arm.idx error')
                            exit()
                        self.bandit.update_arm_with_reward(arm.idx, 1)#, minimizer=True)
 
                        if arm.idx < 4:    # only first arms use random content
                            logger_mic.info('add new arm')
                            self.bandit.add_new_arm(arm)

                    if sample.latest_evasive_minimized_exe_path_mic:
                        logger_mic.info('%s: copy %s' %(sample.sname, sample.latest_evasive_minimized_exe_path_mic))
                        Utils.copy_file(sample.latest_evasive_minimized_exe_path_mic, mic_minimizer_evasive_folder)
                    else:       # only one action, not need minimization
                        path = seq_minimizer_evasive_folder + os.path.basename(sample.path) + '*'
                        logger_mic.info('%s: no evasive in mic minimization, copy %s' %(sample.sname, path))
                        Utils.copy_file(path, mic_minimizer_evasive_folder)
                    sample.delete_tmp_files(rewriter_output_folder)
                    sample.delete_tmp_files(seq_minimizer_output_folder)
                    sample.delete_tmp_files(mic_minimizer_output_folder)
        if rewriter_exit and len(self.list_evasive) == len(self.list_evasive_mic_minimized):
            logger_seq.info('%%%%%%%%%%%%%%%%%%%%%%%% Minimizer Finish %%%%%%%%%%%%%%%%%%%%%%%%')
            logger_mic.info('%%%%%%%%%%%%%%%%%%%%%%%% Minimizer Finish %%%%%%%%%%%%%%%%%%%%%%%%')
            exit()

    def update_rewriter_list(self):
        logger_rew.info('len list_rewriter_working: %d' %len(self.list_rewriter_working))
        list_fail = []
        list_succ = []
        for sample in self.list_rewriter_working:
            # check vm_status
            vm_status = sample.check_file_status(rewriter_vm_folder)
            #logger_rew.info('update rewriter: %s [%s]' %(sample.sname, vm_status))
            if len(sample.list_applied_arm) > 0:
                #logger_rew.info('arm list: %s' %[id(x) for x in sample.list_applied_arm])
                if vm_status == 'deleted':
                    list_fail.append(sample)
                elif vm_status == 'evasive':
                    list_succ.append(sample)

        for sample in list_fail:
            last_arm = sample.list_applied_arm[-1]

            # update reward
            # todo: may need -1 after minimizer
            self.bandit.update_arm_with_reward(last_arm.idx, 0)

            #logger_rew.info('delete sample: %s' %sample.sname))
            self.list_rewriter_working.remove(sample)
            if len(sample.list_applied_arm) >= sample.max_length:
                # restart: delete all related 1) arms 2) files on disk after max_length(10) tries
                logger_rew.info('restart: delete %s related arms and files on disk after max_length(%d) tries' %(sample.sname, sample.max_length))
                sample.delete_applied_arm()
                sample.delete_tmp_files(rewriter_output_folder)
                sample.set_current_exe_path(sample.path)
            self.list_unsolve.append(sample)

        for sample in list_succ:
            last_arm = sample.list_applied_arm[-1]

            self.list_rewriter_working.remove(sample)
            logger_rew.info('### succ! %s' %sample.path)
            os.system('mv %s %s' %(sample.current_exe_path, rewriter_evasive_folder))
            sample.delete_vm_copy(rewriter_vm_folder)
            sample.vm_status = 'deleted'

            ## update reward        # this part have been moved to mic minimizers
            #logger_rew.info('%s: update_arm_with_reward %d %s %d' %(sample.sname, last_arm.idx, last_arm.name, 1))
            #self.bandit.update_arm_with_reward(last_arm.idx, 1)

            ## add new arm
            #if last_arm.idx < 4:    # only first arms use random content
            #    #logger_rew.info('content length: %d' %len(last_arm.content))
            #    logger_rew.info('add new arm')
            #    self.bandit.add_new_arm(last_arm)

            self.list_evasive.append(sample)
        logger_rew.info('==============================================')
        logger_rew.info('list_arm: %d' %len(self.bandit.list_arm))
        for idx, arm in enumerate(self.bandit.list_arm):
            # Bayesian UCB
            logger_rew.info('%-2d %-12s a: %-3d b: %-3d' %(arm.idx, arm.name, self.bandit._as[idx], self.bandit._bs[idx]))

        logger_rew.info('==============================================')

class ContentManager:
    def __init__(self, content_path):
        self.list_unused = []

        logger_rew.info('start to read benign section content')
        list_file = os.listdir(content_path)
        list_file.sort()
        logger_rew.info(len(list_file))
        for filename in list_file:
            name = filename.split('|')[1]
            size = int(filename.split('|')[2])
            if size < Utils.get_smallest_section_size() or size > Utils.get_largest_section_size():
                continue
            with open(content_path + filename, 'rb') as fp:
                content = fp.read()
            self.list_unused.append((name, size, content))
        logger_rew.info('content count: %d' %len(self.list_unused))
        logger_rew.info('finish')

    def get_an_unused_content(self):
        if len(self.list_unused) <= 0:
            logger_rew.info('ERROR! No more section content')
            exit()
        (name, size, content) = random.choice(self.list_unused)
        self.list_unused.remove((name, size, content))

        return name, size, content

class Rewriter:
    def __init__(self, bandit, samples_manager):
        self.data_path = 'data/'
        self.conf_path = 'conf/'
        self.randomize_path = Utils.get_randomized_folder() 
        self.benign_section_content_path = self.data_path + 'benign_section_content/'
        self.recopy = True

        self.bandit = bandit
        self.samples_manager = samples_manager
        self.exit = False
        self.list_selected_arm_idx = []
        
    def run_once(self):
        logger_rew.info('====================== %s =====================' %Utils.get_av_name())
        for sample in self.samples_manager.list_all:
            md5 = sample.get_md5(sample.path)
            print(sample.path, md5)
            for arm in self.bandit.list_arm:
                if arm.action == 'CR':
                    continue
                output_path = arm.pull(sample)
                print(output_path)
                if os.path.exists(output_path):
                    md5_arm = sample.get_md5(output_path)
                    if md5 == md5_arm:
                        print('same arm output. rm %s' %output_path)
                        os.system('rm %s' %output_path)
                with open(sample.path, 'rb') as fp:
                    bytez = fp.read()
                    bytez_new = modify_without_breaking(bytez, [ACTION_MAP[arm.action]])
                    output_path_gym = output_path + '_gym'
                    with open(output_path_gym, 'wb') as fp_out:
                        fp_out.write(bytez_new)
                        if os.path.exists(output_path_gym):
                            md5_arm = sample.get_md5(output_path_gym)
                            if md5 == md5_arm:
                                print('same gym output. rm %s' %output_path_gym)
                                os.system('rm %s' %output_path_gym)
        print('rename \'s/\./\_/\' %s/*' %(os.path.dirname(output_path)))
        os.system('rename \'s/\./\_/\' %s/*' %(os.path.dirname(output_path)))

    def run(self):
        self.samples_manager.get_ori_unsolve_list(rewriter_vm_folder)
        trial_amount = len(self.samples_manager.list_unsolve) * Utils.get_average_pull()
        #logger_rew.info('trial_amount: %d' %trial_amount)
        logger_rew.info('TS: %d update parent: %d' %(Utils.get_thompson_sampling(), Utils.get_update_parent()))

        total_pull_count = 0
        logger_rew.info('===========================================')
        process_count = 0
        skip_count = 0
        solve_count = 0
        need_count = 0
        while(total_pull_count <= trial_amount):
            sample = self.samples_manager.get_next_unsolve_sample()
            if sample:
                arm = self.bandit.get_next_arm(sample.path, sample.get_applied_actions())
                output_path = arm.pull(sample)
                sample.set_current_exe_path(output_path)
                sample.append_arm(arm)
                total_pull_count += 1

                self.list_selected_arm_idx.append(arm.idx)
                #logger_rew.info('list_selected_arm_idx: %s' %self.list_selected_arm_idx)

                sample.copy_to_vm(rewriter_vm_folder)

                skip_count = len(self.samples_manager.list_skip)
                solve_count = len(self.samples_manager.list_evasive)
                need_count = len(self.samples_manager.list_all) - skip_count
                logger_rew.info('-----------------------------------------------')
                logger_rew.info('pull: [%d/%d (%.2f%%)] skip: %d solve: [%d/%d] %.2f%%' %(total_pull_count, trial_amount, total_pull_count/trial_amount * 100, skip_count, solve_count, need_count, solve_count/need_count*100))
                logger_rew.info('-----------------------------------------------')
                process_count += 1
                if process_count % 200 == 0:
                    logger_rew.info('update rewriter working list')
                    self.samples_manager.update_rewriter_list()
            else:
                logger_rew.info('All unsolve samples are processing by arms, or more than %d samples are handing at the same time' %self.samples_manager.sample_concurrent_limit)
                time.sleep(1)
                self.samples_manager.update_rewriter_list()
            if len(self.samples_manager.list_rewriter_working) == 0 and len(self.samples_manager.list_unsolve) == 0:
                solve_count = need_count
                total_pull_count += 1
                logger_rew.info('pull: [%d/%d (%.2f%%)] skip: %d solve: [%d/%d] %.2f%%' %(total_pull_count, trial_amount, total_pull_count/trial_amount * 100, skip_count, solve_count, need_count, solve_count/need_count*100))
                break

        # wait for remaining working samples
        logger_rew.info('wait for remaining working samples')
        while(len(self.samples_manager.list_rewriter_working) > 0):
            logger_rew.info('len(self.samples_manager.list_rewriter_working): %d' %len(self.samples_manager.list_rewriter_working))
            self.samples_manager.update_rewriter_list()
            time.sleep(1)

        logger_rew.info('delete tmp files')
        for sample in self.samples_manager.list_unsolve:
            sample.delete_tmp_files(rewriter_output_folder)

        logger_rew.info('%%%%%%%%%%%%%%%%%%%%%%%% Rewriter Finish %%%%%%%%%%%%%%%%%%%%%%%%')
        self.exit = True
    
    def create_folders(self):
        #if 'ember' in Utils.get_av_name() or 'clamav' in Utils.get_av_name() or 'malconv' in Utils.get_av_name():
        if Utils.get_av_name() in ['avast', 'avira', 'bitdefender', 'kaspersky']:
            cmd = 'sudo umount %s' %Utils.get_share_folder()
            print(cmd)
            os.system(cmd)
            #p = pexpect.spawn( cmd )
            #p.expect( ": " )
            #p.sendline(Utils.get_host_password())

            cmd = 'sudo mount -t cifs -o username=%s,domain=MYDOMAIN,uid=1000 //%s/share/ %s' %(Utils.get_vm_username(), Utils.get_vm_ip(), Utils.get_share_folder())
            print(cmd)
            os.system(cmd)
            ##p = pexpect.spawn( cmd )
            #p.expect( ": " )
            #p.sendline(Utils.get_host_password())
            #p.expect( ": " )
            #p.sendline(Utils.get_vm_password())
            #print(Utils.get_vm_password())
            #output = p.read()

            time.sleep(3)   # manually check share folder is mounted or not

            os.system('rm -f %s/succ_action_count_update.sign' %self.conf_path)
            os.system('rm -f %s/rewriter_finish.sign' %self.conf_path)

        #os.system('mkdir -p log/')

        os.system('mkdir -p %s' %copy_tmp_folder)
        os.system('rm -fr %s/*' %copy_tmp_folder)

        os.system('mkdir -p %s' %rewriter_output_folder)
        os.system('rm -fr %s/*' %rewriter_output_folder)

        os.system('mkdir -p %s' %seq_minimizer_output_folder)
        os.system('rm -fr %s/*' %seq_minimizer_output_folder)

        os.system('mkdir -p %s' %mic_minimizer_output_folder)
        os.system('rm -fr %s/*' %mic_minimizer_output_folder)

        os.system('mkdir -p %s' %rewriter_vm_folder)
        os.system('rm -fr %s/*' %rewriter_vm_folder)

        os.system('mkdir -p %s' %seq_minimizer_vm_folder)
        os.system('rm -fr %s/*' %seq_minimizer_vm_folder)

        os.system('mkdir -p %s' %mic_minimizer_vm_folder)
        os.system('rm -fr %s/*' %mic_minimizer_vm_folder)

        os.system('mkdir -p %s' %rewriter_evasive_folder)
        os.system('rm -fr %s/*' %rewriter_evasive_folder)
        #os.system('mkdir -p %s/almost/' %rewriter_evasive_folder)

        os.system('mkdir -p %s' %seq_minimizer_evasive_folder)
        os.system('rm -fr %s/*' %seq_minimizer_evasive_folder)
        #os.system('mkdir -p %s/almost/' %seq_minimizer_evasive_folder)

        os.system('mkdir -p %s' %mic_minimizer_evasive_folder)
        os.system('rm -fr %s/*' %mic_minimizer_evasive_folder)
        #os.system('mkdir -p %s/almost/' %mic_minimizer_evasive_folder)

    
class Minimizer:
    def __init__(self, samples_manager, rewriter):
        self.samples_manager = samples_manager
        self.rewriter = rewriter

    def run(self):
        while True:
            list_evasive = self.samples_manager.list_evasive
            if len(list_evasive) == 0:
                logger_seq.info('No evasive samples, sleep...')
                logger_mic.info('No evasive samples, sleep...')
                time.sleep(3)

                if self.rewriter.exit:
                    logger_seq.info('%%%%%%%%%%%%%%%%%%%%%%%% Minimizer Finish %%%%%%%%%%%%%%%%%%%%%%%%')
                    logger_mic.info('%%%%%%%%%%%%%%%%%%%%%%%% Minimizer Finish %%%%%%%%%%%%%%%%%%%%%%%%')
                    exit()
            else:
                self.samples_manager.seq_minimize_evasive_sample()
                self.samples_manager.update_seq_minimizer_list()
                self.samples_manager.mic_minimize_evasive_sample()
                self.samples_manager.update_mic_minimizer_list(self.rewriter.exit)
                time.sleep(1)
