from utils import *
import random
import copy
import hashlib
from models import *

from arm import *

if Utils.get_classifier_type() == 'model':
    MALCONV_MODEL_PATH = 'models/malconv/malconv.checkpoint'
    model = MalConvModel( MALCONV_MODEL_PATH, thresh=0.5 )

class Sample:
    def __init__(self, path):
        self.path = path
        self.sname = Utils.short_name(self.path)
        self.set_current_exe_path(self.path)
        self.max_length = Utils.get_max_length()
        self.copy_time = None
        self.status = None      # queue types of which the sample is in. option: [None/pending/working/evasive/minimal/functional]
        self.scan_status = None   # file status on classifier
        self.broken_action_idxs = set()

        self.list_applied_arm = []
        self.current_applied_arm_subset = []
        self.seq_cur_x = 0
        self.seq_cur_y = 0
        self.seq_cur_to_kept_arm = {}
        self.list_minimal_arm = []
        self.latest_minimal_path = None
        self.evasive_path = None

    def reset(self):
        self.set_current_exe_path(self.path)
        self.copy_time = None
        self.status = None
        self.scan_status = None
        self.list_applied_arm = []
        self.current_applied_arm_subset = []
        self.seq_cur_x = 0
        self.seq_cur_y = 0
        self.seq_cur_to_kept_arm = {}
        self.list_minimal_arm = []
        self.latest_minimal_path = None
        self.evasive_path = None
    
    def update_broken_action_idxs(self):
        for arm in self.list_minimal_arm:
            if arm and arm.idx >= 4:
                self.broken_action_idxs.add(arm.idx)

    def set_current_exe_path(self, path):
        self.current_exe_path = path
        self.current_exe_md5 = self.get_md5(path)
        #logger_rew.info('set %s md5 %s' %(path, self.current_exe_md5))

    def inc_seq_cur_x(self):
        self.seq_cur_x += 1
        self.seq_cur_y = 0
    
    def inc_seq_cur_y(self):
        action = self.list_applied_arm[self.seq_cur_x].action
        list_mic_action = []
        if action in ACTION_TO_MICROACTION:
            list_mic_action = ACTION_TO_MICROACTION[action]

        if self.seq_cur_y < len(list_mic_action) - 1:
            self.seq_cur_y += 1
        else:
            self.inc_seq_cur_x()

    def get_md5(self, path):
        if os.path.exists(path) == False:
            logger_rew.info('error! file not exists: %s' %path)
            return None
        hash_md5 = hashlib.md5()
        try:
            with open(path, 'rb') as f:
                content = f.read()
                #for chunk in iter(lambda: f.read(4096), b''):
                #    logger_rew.info('3')
                hash_md5.update(content)
                #logger_rew.info(len(content))
                md5 = hash_md5.hexdigest()
            #logger_rew.info('md5: %s' %md5)
            return md5
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger_rew.error('%s %s:%s cannot get md5' %(exc_type, fname, exc_tb.tb_lineno))
            return None

    def delete_applied_arm(self):
        # clean attributes
        #self.copy_time = None       # need?
        #self.scan_status = None       # need?

        # clean arms
        for arm in self.list_applied_arm:
            del arm
        self.list_applied_arm = []

    def delete_tmp_files(self, folder):
        logger_rew.info('delete generated tmp files in %s' %folder)
        # todo: handle file_name with '.'
        os.system('rm -f %s/%s.*' %(folder, os.path.basename(self.path)))
        self.set_current_exe_path(self.path)

    def append_arm(self, arm):
        self.list_applied_arm.append(arm)

    def copy_to_scan_folder(self, scan_folder):
        #md5 = self.get_md5(self.current_exe_path)
        self.scan_status = 'waiting'
        self.copy_time = time.time()
        Utils.copy_file(self.current_exe_path, scan_folder + os.path.basename(self.current_exe_path + '.exe'))

    def can_be_renamed(self, path):
        tmp_path = os.path.dirname(path) + '/__tmp__' + os.path.basename(path)
        try:
            if os.path.exists(path):
                os.system('mv %s %s' %(path, tmp_path))
                if os.path.exists(tmp_path):
                    os.system('mv %s %s' %(tmp_path, path))
                    if os.path.exists(path):
                        return True
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger_rew.error('%s %s:%s cannot rename' %(exc_type, fname, exc_tb.tb_lineno))
        return False 

    def check_md5(self, filepath):
        file_md5 = self.get_md5(filepath)
        #logger_rew.info('%s: %s %s' %(self.sname, file_md5, self.current_exe_md5))
        if file_md5 and self.current_exe_md5:
            if file_md5 == self.current_exe_md5:
                return True
            else:
                logger_rew.info('%s: md5 changed. delete file.' %self.sname)
                os.system('rm -f %s' %filepath)
                return False
        return None

    def is_remain_after_threshold_time(self):
        wait_time = Utils.get_wait_time()
        existing_time = time.time() - self.copy_time
        #logger_rew.info('exising_time: %d/%d' %(existing_time, wait_time))
        if existing_time > wait_time:
            return True
        else:
            return False

    def delete_scan_folder_copy(self, scan_folder):
        os.system('rm -f %s/%s*' %(scan_folder, os.path.basename(self.path)))

    def check_scan_status(self, scan_folder):
        Utils.wait_on_stop_sign()
        #if 'ember' in Utils.get_classifier_name() or 'clamav' in Utils.get_classifier_name() or 'malconv' in Utils.get_classifier_name():       # classifiers
        if Utils.get_classifier_type() == 'model':
            scan_status = 'deleted'
            for filename in os.listdir(scan_folder):
                if Utils.get_ori_name(filename) == os.path.basename(self.path):
                    if '.benign' in filename:
                        scan_status = 'pass'
                    else:
                        scan_status = 'waiting'
                    break
            if scan_status in ['pass']:
                os.system('rm -f %s/*%s*' %(scan_folder, os.path.basename(self.path)))
            return scan_status
        else:                   # antivirus systems, need to copy file to vm
            list_file = []
            try:
                list_file = [scan_folder + x for x in os.listdir(scan_folder)]
            except Exception as e:
                exc_type, exc_obj, exc_tb = sys.exc_info()
                fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
                logger_rew.info('%s %s:%s cannot listdir' %(exc_type, fname, exc_tb.tb_lineno))
                logger_rew.info(e)
            for filepath in list_file:
                if Utils.get_ori_name(filepath) == os.path.basename(self.path):
                    md5_status = self.check_md5(filepath)
                    #logger_rew.info('%s: md5_status: %s' %(self.sname, md5_status))
                    if md5_status == None:      # cannot access file to get md5
                        scan_status = 'waiting'
                        #if self.is_remain_after_threshold_time():
                        #    scan_status = 'overtime'
                        #else:
                        #    scan_status = 'waiting'
                    elif md5_status == False:   # file md5 is changed
                        scan_status = 'deleted'
                        #if self.can_be_renamed(filepath):  # todo: check
                        #    scan_status = 'deleted'
                        #else:
                        #    if self.is_remain_after_threshold_time():  # todo: check may not need
                        #        scan_status = 'overtime'         # todo: remove overtime?
                        #    else:
                        #        scan_status = 'waiting'
                    else:                       # file md5 stay the same
                        if self.is_remain_after_threshold_time():
                            if self.can_be_renamed(filepath):
                                logger_rew.info('%s: md5 ok; time ok; rename ok' %self.sname)
                                scan_status = 'pass'
                            else:
                                logger_rew.info('%s: cannot rename' %self.sname)
                                #scan_status = 'overtime'
                                #scan_status = 'waiting'
                                scan_status = 'deleted'
                        else:
                            scan_status = 'waiting'  # time is not long enough
                    #logger_rew.info('%s: scan_status: %s' %(self.sname, scan_status))
                    if scan_status in ['pass', 'deleted']:
                        os.system('rm -f %s/*%s*' %(scan_folder, os.path.basename(self.path)))
                    return scan_status
            #logger_rew.info('%s: file not exist' %self.sname)
            scan_status = 'deleted'      # todo: check
            #logger_rew.info('%s: scan_status: %s (cannot find the file)' %(self.sname, scan_status))
            os.system('rm -f %s/*%s*' %(scan_folder, os.path.basename(self.path))) # todo: debug
            return scan_status

    def prepare_action_subset(self):
        list_arm = copy.deepcopy(self.list_applied_arm)

        # replace kept arm
        for k, v in self.seq_cur_to_kept_arm.items():
            #logger_min.info('%s: %d' %(self.sname, k))
            list_arm[k] = v

        logger_min.info('%s: list_arm: %s' %(self.sname, self.get_names_from_arm_list(list_arm)))
        #print('------------------')
        #print('%s: list_arm: %s' %(self.sname, self.get_names_from_arm_list(list_arm)))
        logger_min.info('%s: %d %d' %(self.sname, self.seq_cur_x, self.seq_cur_y))
        #print('%s: %d %d' %(self.sname, self.seq_cur_x, self.seq_cur_y))
        if self.seq_cur_x < len(self.list_applied_arm):
            action = self.list_applied_arm[self.seq_cur_x].action
            #logger_min.info('%s: %s' %(self.sname, action))
            list_mic_action = []
            if action in ACTION_TO_MICROACTION:
                list_mic_action = ACTION_TO_MICROACTION[action]
            #logger_min.info('%s %s' %(self.sname, list_mic_action))
            if self.seq_cur_y < len(list_mic_action):
                minimal_action = list_mic_action[self.seq_cur_y]
                #logger_min.info('%s: %s' %(self.sname, minimal_action))
                if minimal_action == '':          # remove current action
                    minimal_arm = None
                elif minimal_action == 'OA':      # only SA need to be minimized to OA
                    content = self.list_applied_arm[self.seq_cur_x].content
                    minimal_arm = ArmOA(0, content=content)
                elif minimal_action == 'OA1':
                    minimal_arm = ArmOA(0, content=bytes([1]))
                elif minimal_action == 'SA1':     # only SA need to be minimized to SA1
                    minimal_arm = copy.deepcopy(self.list_applied_arm[self.seq_cur_x])
                    minimal_arm.set_content(bytes([1]))
                elif minimal_action == 'SP1':     # only SP need to be minimized to SP1
                    minimal_arm = copy.deepcopy(self.list_applied_arm[self.seq_cur_x])
                    minimal_arm.set_content(bytes([1]))
                elif minimal_action == 'SR1':     # only SR need to be minimized to SR1
                    minimal_arm = copy.deepcopy(self.list_applied_arm[self.seq_cur_x])
                    minimal_arm.mutate_section_name_one_byte()
                elif minimal_action == 'CP1':     # todo: check
                    minimal_arm = ArmCP1(12)
                    #pe = pefile.PE(self.path)
                    #code_section_idx = None
                    #for section_idx, section in enumerate(pe.sections):
                    #    logger_min.info('%s: %d, %s' %(self.sname, section_idx, section.Name[:5].decode('utf-8')))
                    #    logger_min.info(len(section.Name[:5].decode('utf-8')))
                    #    if section.Name[:5].decode('utf-8') == '.text':
                    #        code_section_idx = section_idx
                    #        logger_min.info('%s: find .text in section_idx %d' %(self.sname, code_section_idx))
                    #        break
                    #if code_section_idx != None:
                    #    minimal_arm = ArmSP(2, section_idx=code_section_idx, content=bytes([1]))
                    #else:
                    #    logger_min.info('%s: cannot find code section' %self.sname)
                    #    minimal_arm = None
                else:
                    logger_min.error('%s: minimal_action unexpected: [%s]' %(self.sname, minimal_action))
                    exit()
                list_arm[self.seq_cur_x] = minimal_arm
                logger_min.info('%s: replaced one microaction: %s' %(self.sname, self.get_names_from_arm_list(list_arm)))
            self.current_applied_arm_subset = list_arm
            #logger_min.info('mic_seq_cur_to_kept_arm: %s' %self.mic_seq_cur_to_kept_arm)
        #print(self.sname, [arm.description for arm in list_arm if arm != None])

    def get_names_from_arm_list(self, list_arm):
        list_arm_name = []
        for x in list_arm:
            if x:
                list_arm_name.append(x.action)
            else:
                list_arm_name.append(None)
        return list_arm_name

    def get_minimal_file(self):         # todo: bug in this function error!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        # else: decide which file is evsaive minimal exe, and copy it to minimal_folder
        if self.latest_minimal_path:                # minimal sample
            #logger_min.info('%s: latest_minimal_path %s' %(self.sname, self.latest_minimal_path))
            minimal_path = self.latest_minimal_path
        else:                                           # cannot be minimized
            list_file = [ x for x in os.listdir(evasive_folder) if os.path.basename(self.path)      in x ]
            if len(list_file) == 0:
                logger_min.error('cannot find original evasive sample')
                exit()
            minimal_path = evasive_folder + list_file[0]
            #logger_min.info('%s: cannot be minimized' %(self.sname))
        return minimal_path

    def replay_action_subset(self):
        if len(self.current_applied_arm_subset) == 0:
            logger_min.error('empty replay subset')
            exit()
        input_path = self.path
        for arm in self.current_applied_arm_subset:
            if arm:
                output_path = arm.transfer(input_path, minimizer_output_folder)
                input_path = output_path
                self.set_current_exe_path(output_path)
            else:
                self.set_current_exe_path(input_path)
        #logger_rew.info('output_path: %s' %output_path)

    def get_applied_actions(self):
        return self.get_names_from_arm_list(self.list_applied_arm)

class SamplesManager:
    def __init__(self, sample_folder, bandit):
        self.sample_folder = sample_folder
        self.bandit = bandit
        self.bandit.samples_manager = self
        self.cuckoo = Cuckoo() if Utils.is_cuckoo_enable() else None
        self.list_sample = []   # all samples

        self.sample_concurrent_limit = Utils.get_max_working_sample_count()

        list_file = os.listdir(sample_folder)
        list_file.sort()
        for x in list_file:
            sample = Sample(self.sample_folder + x)
            self.list_sample.append(sample)

    def get_samples_with_status(self, status):
        return [ sample for sample in self.list_sample if sample.status == status ]

    def get_count_with_status(self, status):
        count = 0
        for sample in self.list_sample:
            if sample.status == status:
                count += 1
        return count

    def get_next_pending_sample(self):
        list_pending = self.get_samples_with_status('pending')
        if len(list_pending) > 0:
            for _ in range(10):  # try 10 times     # todo
                sample = random.choice(list_pending)
                count_working = self.get_count_with_status('working')
                if count_working >= self.sample_concurrent_limit:
                    logger_rew.info('concurrent sample %d is more than %d, waiting...' %(count_working, self.sample_concurrent_limit))
                    return None
                else:
                    sample.status = 'working'
                    count_working = self.get_count_with_status('working')
                    logger_rew.info('select pending sample: %s' %sample.sname)
                    logger_rew.info('count_working: %d' %count_working)
                    return sample

    def get_initial_pending_list(self):
        logger_rew.info('check whether classifier can detect unchanged samples...')
        ##### for classifier models
        if Utils.get_classifier_type() == 'model':
            for sample in self.list_sample:
                score = model.get_score(sample.path)
                if score > 0.5:
                    sample.status = 'pending'
                else:
                    sample.status = 'skip'
        ##### for AVs
        elif Utils.get_classifier_type() == 'AV':
            for sample in self.list_sample:
                sample.copy_to_scan_folder(rewriter_scan_folder)
                time.sleep(0.5)
            logger_rew.info('copy to scan folder finish')
            while(True):
                for sample in self.list_sample:
                    if sample.status == None:
                        scan_status = sample.check_scan_status(rewriter_scan_folder)
                        #logger_rew.info('%s: %s' %(sample.sname, scan_status))
                        #if scan_status in ['deleted', 'overtime']:
                        if scan_status == 'deleted':
                            sample.status = 'pending'
                        elif scan_status == 'pass':
                            sample.status = 'skip'
                count_all = len(self.list_sample)
                count_pending = count_skip = 0
                for sample in self.list_sample:
                    if sample.status == 'pending':
                        count_pending += 1
                    elif sample.status == 'skip':
                        count_skip += 1
                logger_rew.info('(%d/%d): detect %d, fail %d' %(count_pending + count_skip, count_all, count_pending, count_skip))
                time.sleep(1)
                if count_pending + count_skip == len(self.list_sample):
                    break
            logger_rew.info('check finish.')
            logger_rew.info('remove remaining files.')
            os.system('rm -f %s/*' %rewriter_scan_folder)

    def update_working_list(self):
        list_working = self.get_samples_with_status('working')
        logger_rew.info('len list_working: %d' %len(list_working))
        list_fail = []
        list_succ = []
        for sample in list_working:
            ############### for AVs, check scan_status
            if Utils.get_classifier_type() == 'AV':
                scan_status = sample.check_scan_status(rewriter_scan_folder)
                #logger_rew.info('update rewriter: %s [%s]' %(sample.sname, scan_status))
                if len(sample.list_applied_arm) > 0:
                    #logger_rew.info('arm list: %s' %[id(x) for x in sample.list_applied_arm])
                    if scan_status == 'deleted':
                        list_fail.append(sample)
                    elif scan_status == 'pass':
                        list_succ.append(sample)
            ############## for classifier models, directly get score
            elif Utils.get_classifier_type() == 'model':
                score = model.get_score(sample.current_exe_path)
                if score > 0.5:
                    list_fail.append(sample)
                else:
                    list_succ.append(sample)
        for sample in list_fail:
            last_arm = sample.list_applied_arm[-1]
            # update reward
            # todo: may need -1 after minimizer
            self.bandit.update_arm_with_reward(sample.path, last_arm.idx, 0)
            #logger_rew.info('delete sample: %s' %sample.sname))
            if len(sample.list_applied_arm) >= sample.max_length:
                # restart: delete all related 1) arms 2) files on disk after max_length(10) tries
                logger_rew.info('restart: delete %s related arms and files on disk after max_length(%d) tries' %(sample.sname, sample.max_length))
                sample.delete_applied_arm()
                sample.delete_tmp_files(rewriter_output_folder)
                sample.set_current_exe_path(sample.path)
            sample.status = 'pending'

        for sample in list_succ:
            last_arm = sample.list_applied_arm[-1]
            logger_rew.info('### Evade! %s' %sample.current_exe_path)
            os.system('mv %s %s' %(sample.current_exe_path, evasive_folder))
            sample.evasive_path = evasive_folder + os.path.basename(sample.current_exe_path)
            sample.set_current_exe_path(sample.evasive_path)
            sample.delete_scan_folder_copy(rewriter_scan_folder)
            sample.scan_status = 'deleted'        # todo: need check
            sample.status = 'evasive'
        logger_rew.info('==============================================')
        logger_rew.info('list_arm: %d' %len(self.bandit.list_arm))
        for idx, arm in enumerate(self.bandit.list_arm):
            # Bayesian UCB
            logger_rew.info('%-2d %-12s alpha: %-3d beta: %-3d' %(arm.idx, arm.description, self.bandit._as[idx], self.bandit._bs[idx]))
        logger_rew.info('==============================================')

    # Use micro actions to replace macro actions
    def minimize_evasive_sample(self):
        list_evasive = self.get_samples_with_status('evasive')
        for sample in list_evasive:
            logger_min.info('sample.scan_status: %s' %sample.scan_status)
            if sample.scan_status in ['deleted', 'pass']:
                if sample.seq_cur_x < len(sample.list_applied_arm):
                    sample.prepare_action_subset()
                    sample.replay_action_subset()
                    logger_min.info('%s: %s cur_idx:%s %s' %(sample.sname, sample.get_names_from_arm_list(sample.list_applied_arm), sample.seq_cur_x, sample.get_names_from_arm_list(sample.current_applied_arm_subset)))
                    if Utils.get_classifier_type() == 'AV':
                        sample.copy_to_scan_folder(minimizer_scan_folder)
                    #elif Utils.get_classifier_type() == 'model':
                    sample.scan_status = 'waiting'
                    #logger_min.info('%s: apply subset to generate: %s' %(sample.sname, os.path.basename(sample.current_exe_path)))

    def update_evasive_list(self, rewriter_exit):
        #for sample in self.list_sample:
        #    logger_min.info('%s: [%s]' %(sample.sname, sample.status))
        list_evasive = self.get_samples_with_status('evasive')
        #logger_min.info('len(list_evasive): %d' %len(list_evasive))
        #if len(list_evasive) > 0:
        #    print('-------------------------')
        for sample in list_evasive:
            # update scan_status
            #logger_min.info('sample.scan_status: %s' %sample.scan_status)
            #if sample.scan_status in ['waiting', 'overtime']:
            if sample.scan_status  == 'waiting':
                ##### for AVs
                if Utils.get_classifier_type() == 'AV':
                    sample.scan_status = sample.check_scan_status(minimizer_scan_folder)
                ##### for classifier model
                elif Utils.get_classifier_type() == 'model':
                    score = model.get_score(sample.current_exe_path)
                    sample.scan_status = 'pass' if score < 0.5 else 'deleted'
                    #print(os.path.basename(sample.current_exe_path), score, sample.scan_status)

                logger_min.info('%s: [%s]' %(sample.sname, sample.scan_status))
                if sample.scan_status == 'deleted': ######################################## todo, error!
                    sample.inc_seq_cur_y()
                    # todo: add arm directly (optional)
                elif sample.scan_status == 'pass':
                    logger_min.info('%s: ### minimize one action! %s' %(sample.sname, sample.current_exe_path))
                    sample.seq_cur_to_kept_arm[sample.seq_cur_x] = sample.current_applied_arm_subset[sample.seq_cur_x]
                    sample.latest_minimal_path = sample.current_exe_path
                    sample.delete_scan_folder_copy(minimizer_scan_folder)
                    #sample.scan_status = 'deleted'
                    sample.list_minimal_arm = [ arm for arm in sample.current_applied_arm_subset if arm ]
                    sample.inc_seq_cur_x()
            #logger_min.info('%s: seq_cur_x: %d len(sample.list_minimal_arm): %d' %(sample.sname, sample.seq_cur_x, len(sample.list_applied_arm)))

            if sample.seq_cur_x >= len(sample.list_applied_arm):
                logger_min.info('%s: ###### minimize finish!!!' %sample.sname)

                minimal_path = sample.get_minimal_file()
                logger_min.info('%s: copy file %s to minimal folder' %(sample.sname, minimal_path))
                Utils.copy_file(minimal_path, minimal_folder)
                sample.latest_minimal_path = minimal_folder + os.path.basename(minimal_path)
                sample.status = 'minimal'

                # find essential arms
                if len(sample.list_minimal_arm) == 0:
                    sample.list_minimal_arm = [ arm for arm in sample.list_applied_arm if arm ]
                logger_min.info('list_minimal_arm: %s' %sample.get_names_from_arm_list(sample.list_minimal_arm))

                # update reward
                for arm in sample.list_minimal_arm:
                    if arm:
                        logger_min.info('%s: update_arm_with_reward %d %s %d' %(sample.sname, arm.idx, arm.description, 1))
                        self.bandit.update_arm_with_reward(sample.path, arm.idx, 1)
                        if arm.idx not in [4,5,6,7,8,9,10,11,12]:   # RD RC BC CR OA1 SA1 SP1 CP1, only first arms use random content
                            logger_min.info('add new arm')
                            self.bandit.add_new_arm(arm)

                    # delete tmp files
                    sample.delete_tmp_files(rewriter_output_folder)
                    sample.delete_tmp_files(minimizer_output_folder)

    def update_minimal_list(self, rewriter_exit):
        list_minimal = self.get_samples_with_status('minimal')
        for sample in list_minimal:
            # if not submitted, submit, otherwise get existing task_id
            minimal_path = sample.get_minimal_file()
            task_id = self.cuckoo.get_task_id(minimal_path)
            #logger_cuc.info('task_id: %s' %task_id)

            cuckoo_status = self.cuckoo.get_task_status(task_id)
            #logger_cuc.info('%s: cuckoo_status: %s' %(sample.sname, cuckoo_status))

            if cuckoo_status == 'reported':
                functional = self.cuckoo.is_functional(task_id, sample.path)
                if functional:
                    # evasive and functional, copy to the final output folder
                    logger_cuc.info('%s: Evasive sample is functional' %sample.sname)
                    Utils.copy_file(minimal_path, functional_folder)
                    sample.status = 'functional'        ########################## this sample is done.
                else:
                    # non-functional, try again
                    logger_cuc.info('%s: Evasive sample is broken, add it back to pool' %sample.sname)
                    sample.update_broken_action_idxs()
                    sample.reset()      # reset members, except broken_action_idxs!!
                    sample.status = 'pending'          ########################## add back to pending queue
                    #sample.status = 'broken'            # todo: debug
                self.cuckoo.del_sample_and_task(minimal_path)    # clean up cuckoo
            else:
                time.sleep(1)
