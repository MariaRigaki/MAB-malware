from utils import *
import random
import copy
from content_manager import ContentManager
from arm import *


class GP:
    def __init__(self):
        #self.arm_limit = get_max_working_arm_count()
        self.content_manager = ContentManager()

        self.samples_manager = None

        self.list_arm = []
        self.list_arm.append(ArmOA(0, content_manager=self.content_manager))
        self.list_arm.append(ArmSA(1, content_manager=self.content_manager))
        self.list_arm.append(ArmSP(2, content_manager=self.content_manager))
        self.list_arm.append(ArmSR(3, content_manager=self.content_manager))
        self.list_arm.append(ArmRD(4))
        self.list_arm.append(ArmRC(5))
        self.list_arm.append(ArmBC(6))
        self.list_arm.append(ArmCR(7))
        #self.list_arm.append(ArmOA(8, content_manager=self.content_manager, content=bytes([1])))    # OA1 todo
        #self.list_arm.append(ArmSA(9, content_manager=self.content_manager, content=bytes([1])))    # SA1 todo
        #self.list_arm.append(ArmSP(10, content_manager=self.content_manager, content=bytes([1])))   # SP1 todo
        #self.list_arm.append(ArmSR(11, content_manager=self.content_manager, mutate_one_byte=True)) # SR1 todo
        #self.list_arm.append(ArmCP1(12))                                                            # CP1 todo
        #self.idx_to_ori_idx = {}

    def get_random_arm(self):
        idx = random.randint(0, len(self.list_arm)-1)
        return self.list_arm[idx]

    def get_next_arm(self, path, list_action):
        cr_path = Utils.get_randomized_folder() + Utils.get_ori_name(path) + '.CR'
        if len(list_action) == 0 and os.path.exists(cr_path):
            idx = 7
        else:
            while True:
                # Tompson Sampling
                samples = [np.random.beta(self._as[x], self._bs[x]) for x in range(len(self.list_arm))]
                idx = max(range(len(self.list_arm)), key=lambda x: samples[x])
                if idx not in [4,5,6,7,8,9,10,11,12]:    # RD RC BC CR OA1 SA1 SP1 CP1 only need once
                    break
                else:
                    if (idx == 4 and 'RD' not in list_action) \
                            or (idx == 5 and 'RC' not in list_action) \
                            or (idx == 6 and 'BC' not in list_action) \
                            or (idx == 7 and 'CR' not in list_action) \
                            or (idx == 8 and 'OA1' not in list_action) \
                            or (idx == 9 and 'SA1' not in list_action) \
                            or (idx == 10 and 'SP1' not in list_action) \
                            or (idx == 11 and 'CR1' not in list_action) \
                            or (idx == 12 and 'CP1' not in list_action):
                        break
                    #else:
                    #    logger_rew.info('does not need %d again for a sample with %s' %(idx, list_action))

        arm = copy.deepcopy(self.list_arm[idx])
        return arm

    def update_arm_with_reward(self, idx, reward):#, minimizer=False):
        if Utils.get_thompson_sampling() == False:
            return

        # Bayesian UCB
        # Update Gaussian posterior
        #if minimizer == False:
        self._as[idx] += reward
        self._bs[idx] += (1 - reward)
        #else:
        #    logger_rew.info('minimizer update reward!')
        #    self._as[idx] += 1
        #    #self._bs[idx] += -1
        
        if Utils.get_update_parent():
            #if child succ, give ori reward too!
            if reward == 1:
                if idx in self.idx_to_ori_idx:
                    ori_idx = self.idx_to_ori_idx[idx]
                    self._as[ori_idx] += reward
                    #self._bs[ori_idx] += (1 - reward)

    def add_new_arm(self, new_arm):
        if Utils.get_thompson_sampling() == False:
            return
        ori_idx = new_arm.idx
        new_arm.idx = len(self.list_arm)

        self.idx_to_ori_idx[new_arm.idx] = ori_idx
        
        # find existing arm
        new_arm.update_name()
        for idx, arm in enumerate(self.list_arm):
            if arm.name == new_arm.name:    # arm already exist, update existing arm
                logger_rew.info('no need to add a new arm, update existing arm')
                self._as[idx] += 1
                return

        # add a new arm, append _as _bs
        self.list_arm.append(new_arm)
        # Bayesian UCB
        #self._as.append(self._as[ori_idx])
        #self._bs.append(self._bs[ori_idx])
        self._as.append(1)
        self._bs.append(1)

class GPRewriter:
    def __init__(self, bandit, samples_manager):
        self.data_path = 'data/'
        self.conf_path = 'conf/'
        self.randomize_path = Utils.get_randomized_folder() 
        #self.benign_section_content_path = self.data_path + 'benign_section_content/'
        self.recopy = True

        self.bandit = bandit
        self.samples_manager = samples_manager
        self.exit = False
        
    def run(self):
        self.samples_manager.get_initial_pending_list()
        self.gp = GP()
        trial_amount = self.samples_manager.get_count_with_status('pending') * Utils.get_average_pull()
        #logger_rew.info('trial_amount: %d' %trial_amount)
        logger_rew.info('TS: %d update parent: %d' %(Utils.is_thompson_sampling(), Utils.get_update_parent()))

        total_pull_count = 0
        logger_rew.info('===========================================')
        process_count = 0
        count_skip = 0
        count_solve = 0
        count_need = 0
        succ_count = fail_count = 0
        list_working = self.samples_manager.get_samples_with_status('pending')
        logger_rew.info(len(list_working))
        list_success_trace = []
        list_promising_trace = []
        max_gen = 15#20
        max_variant = 3#48
        for sample in list_working:
            succ = False
            logger_rew.info('=== %s ==' %sample.sname)
            best_score = None
            best_variant = None
            list_variant = []
            for _ in range(max_variant):
                variant = copy.deepcopy(sample)
                list_variant.append(variant)
            #logger_rew.info('--- generation %d ---' %idx_g)
            logger_rew.info('####################    succ_count: %d, fail_count: %d    ###############' %(succ_count, fail_count))
            for gen_idx in range(max_gen):
                logger_rew.info('gen_idx: %d' %gen_idx)
                trace_count = len(list_success_trace) + len(list_promising_trace)
                if gen_idx == 0 and trace_count > 0:
                    # replay trace
                    logger_rew.info('first gen, replay')
                    for variant in list_variant[:trace_count]:
                        logger_rew.info('list_success_trace count: %d list_promising_trace count: %d' %(len(list_success_trace), len(list_promising_trace)))
                        if len(list_success_trace) > 0:
                            trace = random.choice(list_success_trace)
                        elif len(list_promising_trace) > 0:
                            #logger_rew.info(list_promising_trace)
                            trace = random.choice(list_promising_trace)
                        #logger_rew.info(trace)
                        #variant.list_applied_arm = trace
                        output_path = variant.replay_subset_gp(trace, rewriter_output_folder)
                        new_path = os.path.dirname(output_path) + '/' + os.path.basename(variant.path)
                        new_path = os.path.dirname(output_path) + '/' + os.path.basename(variant.path)
                        print('output_path: %s' %output_path)
                        print(new_path)
                        os.system('mv %s %s' %(output_path, new_path))

                        #s1 = model.get_score(variant.path)
                        #s2 = model.get_score(new_path)
                        #print('ori score: %f replayed score: %f' %(s1, s2))

                        variant.list_applied_arm = []
                        variant.set_current_exe_path(new_path)
                        score = model.get_score(new_path)
                        logger_rew.info('# %s %f' %(os.path.basename(variant.current_exe_path), score))
                        if score < 0.5:
                            succ = True
                            succ_count += 1
                            trace = variant.list_applied_arm
                            if len(trace) > 0:
                                list_success_trace.append(trace)
                                logger_rew.info('success trace: %s' %[x.name for x in trace])
                            break
                        if best_score == None or score < best_score:
                            best_score = score
                            best_variant = variant
                    for variant in list_variant[trace_count:]:
                        arm = self.gp.get_random_arm()
                        output_path = arm.pull(variant)
                        variant.set_current_exe_path(output_path)
                        variant.append_arm(arm)
                        score = model.get_score(output_path)
                        logger_rew.info('# %s %f' %(os.path.basename(variant.current_exe_path), score))
                        if score < 0.5:
                            succ = True
                            succ_count += 1
                            trace = variant.list_applied_arm
                            if len(trace) > 0:
                                list_success_trace.append(trace)
                                logger_rew.info('success trace: %s' %[x.name for x in trace])
                            break
                        if best_score == None or score < best_score:
                            best_score = score
                            best_variant = variant
                else:
                    for variant in list_variant:
                        arm = self.gp.get_random_arm()
                        output_path = arm.transfer(variant.current_exe_path)
                        variant.set_current_exe_path(output_path)
                        variant.append_arm(arm)
                        score = model.get_score(output_path)
                        logger_rew.info('# %s %f' %(os.path.basename(variant.current_exe_path), score))
                        if score < 0.5:
                            succ = True
                            succ_count += 1
                            trace = variant.list_applied_arm
                            if len(trace) > 0:
                                list_success_trace.append(trace)
                                logger_rew.info('success trace: %s' %[x.name for x in trace])
                            break
                        if best_score == None or score < best_score:
                            best_score = score
                            best_variant = variant
                if succ:
                    logger_rew.info('!!!!!!!!!!!!!! evade! best_score: %f' % score)
                    break
            if succ == False:
                fail_count += 1
                logger_rew.info('!!!!!!!!!!!!!! fail, best_score: %f' %best_score)
                trace = best_variant.list_applied_arm
                logger_rew.info('promising trace: %s' %[x.name for x in trace])
                if len(trace) > 0:
                    list_promising_trace.append(trace)
        exit()
        ################################
        while(total_pull_count < trial_amount):
            sample = self.samples_manager.get_next_pending_sample()
            if sample:
                arm = self.bandit.get_next_arm(sample.path, sample.get_applied_actions())
                output_path = arm.pull(sample)
                sample.set_current_exe_path(output_path)
                sample.append_arm(arm)
                total_pull_count += 1
                sample.copy_to_scan_folder(rewriter_scan_folder)
                process_count += 1
                if process_count % 200 == 0:
                    logger_rew.info('update rewriter working list')
                    self.samples_manager.update_working_list()
            else:
                logger_rew.info('All pending samples are processing by arms, or more than %d samples are handing at the same time' %self.samples_manager.sample_concurrent_limit)
                time.sleep(1)
                self.samples_manager.update_working_list()

            count_skip = self.samples_manager.get_count_with_status('skip')
            count_evasive = self.samples_manager.get_count_with_status('evasive')
            count_minimal = self.samples_manager.get_count_with_status('minimal')
            count_functional = self.samples_manager.get_count_with_status('functional')
            count_need = len(self.samples_manager.list_sample) - count_skip
            logger_rew.info('-----------------------------------------------')
            logger_rew.info('### [%d/%d (%.2f%%)] skip: %d evasive: %d/%d (%.2f%%) minimal: %d functioanl: %d' \
                    %(total_pull_count, trial_amount, total_pull_count/trial_amount * 100, count_skip, \
                    count_evasive + count_minimal + count_functional, count_need, \
                    ((count_evasive + count_minimal + count_functional)/count_need*100), \
                    count_minimal + count_functional, count_functional))
            logger_rew.info('-----------------------------------------------')

            if count_functional + count_skip == len(self.samples_manager.list_sample):
                break

        # wait for remaining working samples
        logger_rew.info('wait for remaining working samples')
        while True:
            count_working = self.samples_manager.get_count_with_status('working')
            count_evasive = self.samples_manager.get_count_with_status('evasive')
            count_minimal = self.samples_manager.get_count_with_status('minimal')
            if count_working + count_evasive + count_minimal == 0:
                break
            logger_rew.info('count_working: %d' %count_working)
            self.samples_manager.update_working_list()
            time.sleep(1)

        logger_rew.info('delete tmp files')
        list_pending = self.samples_manager.get_samples_with_status('pending')
        for sample in list_pending:
            sample.delete_tmp_files(rewriter_output_folder)

        logger_rew.info('%%%%%%%%%%%%%%%%%%%%%%%% Rewriter Finish %%%%%%%%%%%%%%%%%%%%%%%%')
        self.exit = True