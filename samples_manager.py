from utils import *
import random
from models import *
from sample import Sample
from arm import *

class SamplesManager:
    def __init__(self, sample_folder, bandit):
        self.sample_folder = sample_folder
        self.bandit = bandit
        self.bandit.samples_manager = self
        self.cuckoo = Cuckoo() if Utils.is_cuckoo_enable() else None
        self.list_sample = []   # all samples

        self.sample_concurrent_limit = Utils.get_max_working_sample_count()

        list_file = os.listdir(sample_folder)
        list_file.sort()
        for x in list_file:
            sample = Sample(self.sample_folder + x)
            self.list_sample.append(sample)

    def get_samples_with_status(self, status):
        return [ sample for sample in self.list_sample if sample.status == status ]

    def get_count_with_status(self, status):
        count = 0
        for sample in self.list_sample:
            if sample.status == status:
                count += 1
        return count

    def get_next_pending_sample(self):
        list_pending = self.get_samples_with_status('pending')
        if len(list_pending) > 0:
            for _ in range(10):  # try 10 times     # todo
                sample = random.choice(list_pending)
                count_working = self.get_count_with_status('working')
                if count_working >= self.sample_concurrent_limit:
                    logger_rew.info('concurrent sample %d is more than %d, waiting...' %(count_working, self.sample_concurrent_limit))
                    return None
                else:
                    sample.status = 'working'
                    count_working = self.get_count_with_status('working')
                    logger_rew.info('select pending sample: %s' %sample.sname)
                    logger_rew.info('count_working: %d' %count_working)
                    return sample

    def get_initial_pending_list(self):
        logger_rew.info('check whether classifier can detect unchanged samples...')
        ##### for classifier models
        if Utils.get_classifier_evaluate_type() == 'query':
            for sample in self.list_sample:
                sample.status = 'skip' if model.is_evasive(sample.path) else 'pending'
                # score = model.get_score(sample.path)
                # if score > model.thresh:
                #     sample.status = 'pending'
                # else:
                #     sample.status = 'skip'
        ##### for AVs
        elif Utils.get_classifier_evaluate_type() == 'scan_folder':
            for sample in self.list_sample:
                sample.copy_to_scan_folder(rewriter_scan_folder)
                time.sleep(2)
            logger_rew.info('copy to scan folder finish')
            while(True):
                for sample in self.list_sample:
                    if sample.status == None:
                        scan_status = sample.check_scan_status(rewriter_scan_folder)
                        #logger_rew.info('%s: %s' %(sample.sname, scan_status))
                        #if scan_status in ['deleted', 'overtime']:
                        if scan_status == 'deleted':
                            sample.status = 'pending'
                        elif scan_status == 'pass':
                            sample.status = 'skip'
                count_all = len(self.list_sample)
                count_pending = count_skip = 0
                for sample in self.list_sample:
                    if sample.status == 'pending':
                        count_pending += 1
                    elif sample.status == 'skip':
                        count_skip += 1
                logger_rew.info('(%d/%d): detect %d, fail %d' %(count_pending + count_skip, count_all, count_pending, count_skip))
                time.sleep(1)
                if count_pending + count_skip == len(self.list_sample):
                    break
            logger_rew.info('check finish.')
            logger_rew.info('remove remaining files.')
            os.system('rm -f %s/*' %rewriter_scan_folder)

    def update_working_list(self):
        list_working = self.get_samples_with_status('working')
        logger_rew.info('len list_working: %d' %len(list_working))
        list_fail = []
        list_succ = []
        for sample in list_working:
            ############### for AVs, check scan_status
            if Utils.get_classifier_evaluate_type() == 'scan_folder':
                scan_status = sample.check_scan_status(rewriter_scan_folder)
                #logger_rew.info('update rewriter: %s [%s]' %(sample.sname, scan_status))
                if len(sample.list_applied_arm) > 0:
                    #logger_rew.info('arm list: %s' %[id(x) for x in sample.list_applied_arm])
                    if scan_status == 'deleted':
                        list_fail.append(sample)
                    elif scan_status == 'pass':
                        list_succ.append(sample)
            ############## for classifier models, directly get score
            elif Utils.get_classifier_evaluate_type() == 'query':
                score = model.get_score(sample.current_exe_path)
                if score > model.thresh:
                    list_fail.append(sample)
                else:
                    list_succ.append(sample)
        for sample in list_fail:
            last_arm = sample.list_applied_arm[-1]
            # update reward
            # todo: may need -1 after minimizer
            self.bandit.update_arm_with_reward(sample.path, last_arm.idx, 0)
            #logger_rew.info('delete sample: %s' %sample.sname))
            if len(sample.list_applied_arm) >= sample.max_length:
                # restart: delete all related 1) arms 2) files on disk after max_length(10) tries
                logger_rew.info('restart: delete %s related arms and files on disk after max_length(%d) tries' %(sample.sname, sample.max_length))
                sample.delete_applied_arm()
                sample.delete_tmp_files(rewriter_output_folder)
                sample.set_current_exe_path(sample.path)
            sample.status = 'pending'

        for sample in list_succ:
            last_arm = sample.list_applied_arm[-1]
            logger_rew.info('### Evade! %s' %sample.current_exe_path)
            os.system('mv %s %s' %(sample.current_exe_path, evasive_folder))
            sample.evasive_path = evasive_folder + os.path.basename(sample.current_exe_path)
            sample.set_current_exe_path(sample.evasive_path)
            sample.delete_scan_folder_copy(rewriter_scan_folder)
            sample.scan_status = 'deleted'        # todo: need check
            sample.status = 'evasive'
        logger_rew.info('==============================================')
        logger_rew.info('list_arm: %d' %len(self.bandit.list_arm))
        for idx, arm in enumerate(self.bandit.list_arm):
            # Bayesian UCB
            logger_rew.info('%-2d %-12s alpha: %-3d beta: %-3d' %(arm.idx, arm.description, self.bandit._as[idx], self.bandit._bs[idx]))
        logger_rew.info('==============================================')

    # Use micro actions to replace macro actions
    def minimize_evasive_sample(self):
        list_evasive = self.get_samples_with_status('evasive')
        for sample in list_evasive:
            logger_min.info('sample.scan_status: %s' %sample.scan_status)
            if sample.scan_status in ['deleted', 'pass']:
                if sample.seq_cur_x < len(sample.list_applied_arm):
                    sample.prepare_action_subset()
                    sample.replay_action_subset()
                    logger_min.info('%s: %s cur_idx:%s %s' %(sample.sname, sample.get_names_from_arm_list(sample.list_applied_arm), sample.seq_cur_x, sample.get_names_from_arm_list(sample.current_applied_arm_subset)))
                    if Utils.get_classifier_evaluate_type() == 'scan_folder':
                        sample.copy_to_scan_folder(minimizer_scan_folder)
                    #elif Utils.get_classifier_evaluate_type() == 'query':
                    sample.scan_status = 'waiting'
                    #logger_min.info('%s: apply subset to generate: %s' %(sample.sname, os.path.basename(sample.current_exe_path)))

    def update_evasive_list(self, rewriter_exit):
        #for sample in self.list_sample:
        #    logger_min.info('%s: [%s]' %(sample.sname, sample.status))
        list_evasive = self.get_samples_with_status('evasive')
        #logger_min.info('len(list_evasive): %d' %len(list_evasive))
        #if len(list_evasive) > 0:
        #    print('-------------------------')
        for sample in list_evasive:
            # update scan_status
            #logger_min.info('sample.scan_status: %s' %sample.scan_status)
            #if sample.scan_status in ['waiting', 'overtime']:
            if sample.scan_status  == 'waiting':
                ##### for AVs
                if Utils.get_classifier_evaluate_type() == 'scan_folder':
                    sample.scan_status = sample.check_scan_status(minimizer_scan_folder)
                ##### for classifier model
                elif Utils.get_classifier_evaluate_type() == 'query':
                    score = model.get_score(sample.current_exe_path)
                    sample.scan_status = 'pass' if score < model.thresh else 'deleted'
                    #print(os.path.basename(sample.current_exe_path), score, sample.scan_status)

                logger_min.info('%s: [%s]' %(sample.sname, sample.scan_status))
                if sample.scan_status == 'deleted': ######################################## todo, error!
                    sample.inc_seq_cur_y()
                    # todo: add arm directly (optional)
                elif sample.scan_status == 'pass':
                    logger_min.info('%s: ### minimize one action! %s' %(sample.sname, sample.current_exe_path))
                    sample.seq_cur_to_kept_arm[sample.seq_cur_x] = sample.current_applied_arm_subset[sample.seq_cur_x]
                    sample.latest_minimal_path = sample.current_exe_path
                    sample.delete_scan_folder_copy(minimizer_scan_folder)
                    #sample.scan_status = 'deleted'
                    sample.list_minimal_arm = [ arm for arm in sample.current_applied_arm_subset if arm ]
                    sample.inc_seq_cur_x()
            #logger_min.info('%s: seq_cur_x: %d len(sample.list_minimal_arm): %d' %(sample.sname, sample.seq_cur_x, len(sample.list_applied_arm)))

            if sample.seq_cur_x >= len(sample.list_applied_arm):
                logger_min.info('%s: ###### minimize finish!!!' %sample.sname)

                minimal_path = sample.get_minimal_file()
                logger_min.info('%s: copy file %s to minimal folder' %(sample.sname, minimal_path))
                Utils.copy_file(minimal_path, minimal_folder)
                sample.latest_minimal_path = minimal_folder + os.path.basename(minimal_path)
                sample.status = 'minimal'

                # find essential arms
                if len(sample.list_minimal_arm) == 0:
                    sample.list_minimal_arm = [ arm for arm in sample.list_applied_arm if arm ]
                logger_min.info('list_minimal_arm: %s' %sample.get_names_from_arm_list(sample.list_minimal_arm))

                # update reward
                for arm in sample.list_minimal_arm:
                    if arm:
                        logger_min.info('%s: update_arm_with_reward %d %s %d' %(sample.sname, arm.idx, arm.description, 1))
                        self.bandit.update_arm_with_reward(sample.path, arm.idx, 1)
                        if arm.idx not in [4,5,6,7,8,9,10,11,12]:   # RD RC BC CR OA1 SA1 SP1 CP1, only first arms use random content
                            logger_min.info('add new arm')
                            self.bandit.add_new_arm(arm)

                    # delete tmp files
                    sample.delete_tmp_files(rewriter_output_folder)
                    sample.delete_tmp_files(minimizer_output_folder)

    def update_minimal_list(self, rewriter_exit):
        list_minimal = self.get_samples_with_status('minimal')
        for sample in list_minimal:
            # if not submitted, submit, otherwise get existing task_id
            minimal_path = sample.get_minimal_file()
            task_id = self.cuckoo.get_task_id(minimal_path)
            #logger_cuc.info('task_id: %s' %task_id)

            cuckoo_status = self.cuckoo.get_task_status(task_id)
            #logger_cuc.info('%s: cuckoo_status: %s' %(sample.sname, cuckoo_status))

            if cuckoo_status == 'reported':
                functional = self.cuckoo.is_functional(task_id, sample.path)
                if functional:
                    # evasive and functional, copy to the final output folder
                    logger_cuc.info('%s: Evasive sample is functional' %sample.sname)
                    Utils.copy_file(minimal_path, functional_folder)
                    sample.status = 'functional'        ########################## this sample is done.
                else:
                    # non-functional, try again
                    logger_cuc.info('%s: Evasive sample is broken, add it back to pool' %sample.sname)
                    sample.update_broken_action_idxs()
                    sample.reset()      # reset members, except broken_action_idxs!!
                    sample.status = 'pending'          ########################## add back to pending queue
                    #sample.status = 'broken'            # todo: debug
                self.cuckoo.del_sample_and_task(minimal_path)    # clean up cuckoo
            else:
                time.sleep(1)
