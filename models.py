import torch
import time
import requests
import torch.nn.functional as F
from MalConv import MalConv
#from src.model import MalConv
from ember import predict_sample
import lightgbm as lgb
import numpy as np
import clamd
import gzip
from ember import PEFeatureExtractor
import json
import os
import random

#class MalConvModel2(object):
#    def __init__(self, model_path, thresh=0.5, name='malconv2'): 
#        print(model_path)
#        self.model = torch.load(model_path)
#        self.model.eval()
#        #weights = torch.load(model_path)#,map_location='cpu')
#        #self.model.load_state_dict( weights['model_state_dict'])
#        self.thresh = thresh
#        self.__name__ = name
#
#    def predict(self, file_path):
#        return self.get_score(file_path) > self.thresh
#
#    def get_score(self, file_path):
#        with open(file_path, 'rb') as fp:
#            bytez = fp.read()
#            _inp = torch.from_numpy( np.frombuffer(bytez,dtype=np.uint8)[np.newaxis,:] )
#
#            #exe_input = val_batch_data[0]
#            exe_input = _inp
#            exe_input = Variable(exe_input.long(),requires_grad=False)
#    
#            pred = self.model(exe_input)
#
#            #with torch.no_grad():
#            #    outputs = F.softmax( self.model(_inp), dim=-1)
#            #return outputs.detach().numpy()[0,1]
#            return pred.detach().numpy()[0,1]

class MalConvModel(object):
    def __init__(self, model_path, thresh=0.5, name='malconv'): 
        self.model = MalConv(channels=256, window_size=512, embd_size=8).train()
        weights = torch.load(model_path,map_location='cpu')
        self.model.load_state_dict( weights['model_state_dict'])
        self.thresh = thresh
        self.__name__ = name

    def predict(self, file_path):
        return self.get_score(file_path) > self.thresh
        #with open(file_path, 'rb') as fp:
        #    bytez = fp.read()
        #    _inp = torch.from_numpy( np.frombuffer(bytez,dtype=np.uint8)[np.newaxis,:] )
        #    with torch.no_grad():
        #        outputs = F.softmax( self.model(_inp), dim=-1)

        #    return outputs.detach().numpy()[0,1] > self.thresh

    def get_score(self, file_path):
        ### code for debug!
        # if len(os.path.basename(file_path)) > 70:
        #     i = random.randint(1, 50)
        #     if i == 10:
        #         return 0.444444 
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            _inp = torch.from_numpy( np.frombuffer(bytez,dtype=np.uint8)[np.newaxis,:] )
            with torch.no_grad():
                outputs = F.softmax( self.model(_inp), dim=-1)
            return outputs.detach().numpy()[0,1]
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        print(os.path.basename(file_path), score)
        return True if score < self.thresh else False

class EmberModel_gym(object):      # model in gym-malware
    # ember_threshold = 0.8336 # resulting in 1% FPR
    def __init__(self, model_path, thresh=0.9, name='ember'):
        # load lightgbm model
        # self.model = lgb.Booster(model_file=model_path)
        self.local_model = joblib.load(model_path)
        self.thresh = thresh
        self.__name__ = 'ember'

    def predict(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            #return predict_sample(self.model, bytez) > self.thresh
            features = feature_extractor.extract( bytez )
            score = local_model.predict_proba( features.reshape(1,-1) )[0,-1]
            return score >= self.thresh

class EmberModel_2019(object):       # model in MLSEC 2019
    # ember_threshold = 0.8336 # resulting in 1% FPR
    def __init__(self, model_path, thresh=0.8336, name='ember'):
        # load lightgbm model
        self.model = lgb.Booster(model_file=model_path)
        self.thresh = thresh
        self.__name__ = 'ember'

    def predict(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            score = predict_sample(self.model, bytez)
            return score > self.thresh

    def get_score(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            print(len(bytez))
            score = predict_sample(self.model, bytez)
            return score
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        print(os.path.basename(file_path), score)
        return True if score < self.thresh else False


class EmberModel_2020(object):      # model in MLSEC 2020
    '''Implements predict(self, bytez)'''
    def __init__(self,
                 name: str = 'ember_MLSEC202H0',
                 thresh=0.8336):
        self.thresh = thresh
        self.__name__ = name

    #def predict(self, bytez: bytes) -> int:
    def predict(self, file_path) -> int:
        return not self.is_evasive(file_path)
        #with open(file_path, 'rb') as fp:
        #    bytez = fp.read()
        #    return self.get_label(bytez)

    def get_score(self, file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            url = 'http://127.0.0.1:8080/'
            timeout = 5
            error_msg = None
            res = None
            start = time.time()
            try:
                res = self.get_raw_result(bytez, url, timeout)
                score = res.json()['score']
            except (requests.RequestException, KeyError, json.decoder.JSONDecodeError) as e:
                score = 1.0  # timeout or other error results in malicious
                error_msg = str(e)
                if res:
                    error_msg += f'-{res.text()}'
            return score
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        print(os.path.basename(file_path), score)
        return True if score < self.thresh else False
    
    def get_raw_result(self, bytez, url, timeout):
        return requests.post(url, data=bytez, headers={'Content-Type': 'application/octet-stream'}, timeout=timeout)

#### for gym-malware?
# class EmberModel_2020(object):      # model in MLSEC 2020
#     '''Implements predict(self, bytez)'''
#     def __init__(self,
#                  name: str = 'ember_MLSEC202H0'):
#         self.__name__ = name

#     #def predict(self, bytez: bytes) -> int:
#     def predict(self, file_path) -> int:
#         with open(file_path, 'rb') as fp:
#             bytez = fp.read()
#             return self.get_label_remote(bytez)

#     def get_score_remote(self, bytez):
#         url = 'http://127.0.0.1:8080/'
#         timeout = 5
#         error_msg = None
#         res = None
#         start = time.time()
#         try:
#             res = self.get_raw_result(bytez, url, timeout)
#             score = res.json()['score']
#         except (requests.RequestException, KeyError, json.decoder.JSONDecodeError) as e:
#             score = 1.0  # timeout or other error results in malicious
#             error_msg = str(e)
#             if res:
#                 error_msg += f'-{res.text()}'
    
#         return score
    
#     def get_label_remote(self, bytez):
#         url = 'http://127.0.0.1:8080/'
#         timeout = 20
#         error_msg = None
#         res = None
#         start = time.time()
#         try:
#             res = self.get_raw_result(bytez, url, timeout)
#             result = res.json()['result']
#         except (requests.RequestException, KeyError, json.decoder.JSONDecodeError) as e:
#             # todo: try again later
#             print('!!!!!!!!!!!!!!! exception timeout !!!!!!!!!!!!!!!!1')
#             exit()
#             result = 1  # timeout or other error results in malicious
#             error_msg = str(e)
#             if res:
#                 error_msg += f'-{res.text()}'
    
#         return result
    
#     def get_raw_result(self, bytez, url, timeout):
#         return requests.post(url, data=bytez, headers={'Content-Type': 'application/octet-stream'}, timeout=timeout)

class ClamAV(object):
    def __init__(self):
        self.model = clamd.ClamdUnixSocket()
        #self.model = pyclamd.ClamdAgnostic()

    def predict(self, file_path):
        res = self.model.scan(file_path)
        #res = self.model.scan_file(file_path)
        print(res)
        if '\'FOUND\'' in str(res):
            return True
        elif '\'OK\'' in str(res):
            return False
        else:
            print('clamav error')
            exit()
