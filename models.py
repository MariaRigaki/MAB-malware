import torch
from torch import nn

import time
import requests
import torch.nn.functional as F
import lightgbm as lgb
import numpy as np
import subprocess
import json
from ember import predict_sample, PEFeatureExtractor
from MalConv import MalConv
import sys
import tensorflow as tf
import os
import joblib

class MalConvModel(object):
    def __init__(self, model_path, thresh=0.5, name='malconv'): 
        self.model = MalConv(channels=256, window_size=512, embd_size=8).train()
        weights = torch.load(model_path,map_location='cpu')
        self.model.load_state_dict( weights['model_state_dict'])
        self.thresh = thresh
        self.__name__ = name

    def get_score(self, file_path):
        try:
            with open(file_path, 'rb') as fp:
                bytez = fp.read(2000000)        # read the first 2000000 bytes
                _inp = torch.from_numpy( np.frombuffer(bytez,dtype=np.uint8)[np.newaxis,:] )
                with torch.no_grad():
                    outputs = F.softmax( self.model(_inp), dim=-1)
                return outputs.detach().numpy()[0,1]
        except Exception as e:
            print(e)
        return 0.0 
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        #print(os.path.basename(file_path), score)
        return score < self.thresh

#class EmberModel_gym(object):      # model in gym-malware
#    # ember_threshold = 0.8336 # resulting in 1% FPR
#    def __init__(self, model_path, thresh=0.9, name='ember'):       # 0.9 or 0.8336
#        # load lightgbm model
#        self.local_model = joblib.load(model_path)
#        self.thresh = thresh
#        self.__name__ = 'ember'
#
#    def get_score(self, file_path):
#        with open(file_path, 'rb') as fp:
#            bytez = fp.read()
#            #return predict_sample(self.model, bytez) > self.thresh
#            features = feature_extractor.extract( bytez )
#            score = local_model.predict_proba( features.reshape(1,-1) )[0,-1]
#            return score
#    
#    def is_evasive(self, file_path):
#        score = self.get_score(file_path)
#        return score < self.thresh

class LGBModel(object):       # model in MLSEC 2019
    def __init__(self, model_path, thresh=0.8336, name='ember'):
        # load lightgbm model
        self.model = lgb.Booster(model_file=model_path)
        self.thresh = thresh
        self.__name__ = 'ember'

    def get_score(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
            score = predict_sample(self.model, bytez)
            return score
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        return score < self.thresh

#class EmberModel_2020(object):      # model in MLSEC 2020
#    '''Implements predict(self, bytez)'''
#    def __init__(self,
#                 name: str = 'ember_MLSEC202H0',
#                 thresh=0.8336):
#        self.thresh = thresh
#        self.__name__ = name
#
#    def get_score(self, file_path):
#        with open(file_path, 'rb') as fp:
#            bytez = fp.read()
#            url = 'http://127.0.0.1:8080/'
#            timeout = 5
#            error_msg = None
#            res = None
#            start = time.time()
#            try:
#                res = self.get_raw_result(bytez, url, timeout)
#                score = res.json()['score']
#            except (requests.RequestException, KeyError, json.decoder.JSONDecodeError) as e:
#                score = 1.0  # timeout or other error results in malicious
#                error_msg = str(e)
#                if res:
#                    error_msg += f'-{res.text()}'
#            return score
#    
#    def is_evasive(self, file_path):
#        score = self.get_score(file_path)
#        return score < self.thresh
#    
#    def get_raw_result(self, bytez, url, timeout):
#        return requests.post(url, data=bytez, headers={'Content-Type': 'application/octet-stream'}, timeout=timeout)

class ClamAV(object):
    def is_evasive(self, file_path):
        res = subprocess.run(['clamdscan', '--fdpass', file_path], stdout=subprocess.PIPE)
        #print(res.stdout)
        if 'FOUND' in str(res.stdout):
            return False
        elif 'OK' in str(res.stdout):
            return True
        else:
            print('clamav error')
            exit()

class KerasModel(object):       # model in MLSEC 2019
    def __init__(self, model_path, scaler_path, thresh=0.5, name='keras', dual_input=False):
        # load lightgbm model
        self.model = tf.keras.models.load_model(model_path)
        self.thresh = thresh
        self.__name__ = name
        self.dual = dual_input
        
        if scaler_path is not None:
            if not os.path.isfile(model_path):
                raise FileNotFoundError(f'{model_path} not exists')
            self._scaler = joblib.load(scaler_path)
        else:
            self._scaler = None


    def preprocess(self, bytez):
        extractor = PEFeatureExtractor(2, print_feature_warning=False)
        features = np.array(extractor.feature_vector(bytez), dtype=np.float32)
        features = self._scaler.transform(features.reshape(1, -1))
        features = np.clip(features, -5, 5)

        return features

    def get_score(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
        
        features = self.preprocess(bytez)
        
        if self.dual:
            score = self.model.predict((features, 0.5*np.ones((1, 1))))[0][0]
        else:
            score = self.model.predict(features)[0][0]

        return score
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        return score < self.thresh


class SorelNet(nn.Module):
	"""
	This is a simple network loosely based on the one used in ALOHA: Auxiliary Loss Optimization for Hypothesis Augmentation (https://arxiv.org/abs/1903.05700)
	Note that it uses fewer (and smaller) layers, as well as a single layer for all tag predictions, performance will suffer accordingly.
	"""

	def __init__(self, use_malware=True, use_counts=True, use_tags=True, n_tags=None, feature_dimension=2381,
				 layer_sizes=None):
		self.use_malware = use_malware
		self.use_counts = use_counts
		self.use_tags = use_tags
		self.n_tags = n_tags
		if self.use_tags and self.n_tags == None:
			raise ValueError("n_tags was None but we're trying to predict tags. Please include n_tags")
		super().__init__()
		p = 0.05
		layers = []
		if layer_sizes is None: layer_sizes = [512, 512, 128]
		for i, ls in enumerate(layer_sizes):
			if i == 0:
				layers.append(nn.Linear(feature_dimension, ls))
			else:
				layers.append(nn.Linear(layer_sizes[i - 1], ls))
			layers.append(nn.LayerNorm(ls))
			layers.append(nn.ELU())
			layers.append(nn.Dropout(p))
		self.model_base = nn.Sequential(*tuple(layers))
		self.malware_head = nn.Sequential(nn.Linear(layer_sizes[-1], 1),
										  nn.Sigmoid())
		self.count_head = nn.Linear(layer_sizes[-1], 1)
		self.sigmoid = nn.Sigmoid()
		self.tag_head = nn.Sequential(nn.Linear(layer_sizes[-1], 64),
									  nn.ELU(),
									  nn.Linear(64, 64),
									  nn.ELU(),
									  nn.Linear(64, n_tags),
									  nn.Sigmoid())

	def forward(self, data):
		rv = {}
		base_result = self.model_base.forward(data)
		if self.use_malware:
			rv['malware'] = self.malware_head(base_result)
		if self.use_counts:
			rv['count'] = self.count_head(base_result)
		if self.use_tags:
			rv['tags'] = self.tag_head(base_result)
		return rv


class SorelModel(object):
    def __init__(self, model_path, thresh=0.5, name='sorelFCNN',
            use_malware=True, use_counts=True, use_tags=True, n_tags=11,
			feature_dimension=2381, layer_sizes=None):
        self._sorel = SorelNet(use_malware, use_counts, use_tags, n_tags, feature_dimension, layer_sizes)
        if not os.path.isfile(model_path):
            raise FileNotFoundError(f'{model_path} not exists')
        self.load_model(model_path)
        self.thresh = thresh
        self.use_cuda = False # torch.cuda.is_available(

    def load_model(self, model_path):
        # state_dict = torch.load(model_path) if self.use_cuda else torch.load(model_path, map_location='cpu')
        state_dict = torch.load(model_path, map_location='cpu')
        self._sorel.load_state_dict(state_dict)
        # if self.use_cuda:
            # self._sorel.cuda()
        self._sorel.eval()
        self._classes = 3 + self._sorel.n_tags
        self._n_features = 2381
        return self
        
    def features_postproc_func(self, x):
        x1 = np.asarray(x[0], dtype=np.float32).copy()
        lz = x1 < 0
        gz = x1 > 0
        x1[lz] = - np.log(1 - x1[lz])
        x1[gz] = np.log(1 + x1[gz])
        return x1

    def preprocess(self, bytez):
        extractor = PEFeatureExtractor(2, print_feature_warning=False)
        features = np.array(extractor.feature_vector(bytez), dtype=np.float32).reshape(1, -1)
        features = self.features_postproc_func(features)

        return features

    def get_score(self,file_path):
        with open(file_path, 'rb') as fp:
            bytez = fp.read()
        
        features = torch.tensor(self.preprocess(bytez))
        # if self.use_cuda:
            # features.cuda()        
        
        rv = self._sorel.forward(features)
        score = rv['malware'].item() if 'malware' in rv else 0
        # count_score = rv['count'].item() if 'count' in rv else 0
        # tags_score = [r for r in rv['tags'].flatten().tolist()] if 'tags' in rv else [0] * self._sorel.n_tags

        return score
    
    def is_evasive(self, file_path):
        score = self.get_score(file_path)
        return score < self.thresh